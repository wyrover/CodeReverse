////////////////////////////////////////////////////////////////////////////
// arch_x32.dat
// Copyright (C) 2015 Katayama Hirofumi MZ.  All rights reserved.
////////////////////////////////////////////////////////////////////////////
// This file is part of CodeReverse.
// This file might be incomplete and/or incorrect.
////////////////////////////////////////////////////////////////////////////
// [Attributes]
// .addr:   address
// .type:   type
// .bits:   size in bits
//
// [Types]
// $type.s8:    signed 8-bit type
// $type.u8:    unsigned 8-bit type
// $type.x8:    signed/unsigned 8-bit type
// $type.s16:   signed 16-bit type
// $type.u16:   unsigned 16-bit type
// $type.x16:   signed/unsigned 16-bit type
// $type.s32:   signed 32-bit type
// $type.u32:   unsigned 32-bit type
// $type.x32:   signed/unsigned 32-bit type
// $type.ptr(ty):   make a pointer type to the type ty
// $type.ref(ty):   make a base type of the pointer type ty
//
// [Values]
// .value:  value
// .svalue: signed value
// .uvalue: unsigned value
// .pvalue: pointer value
// .avalue: label value
//
// [Functions]
// $fn.fname:   a call of the function named fname
//
// [Parameters]
// $0, $1, $2, ...:         parameters
// $0N, $1N, $2N, ...:      numeric parameters
// $0R, $1R, $2R, ...:      register parameters
// $0M, $1M, $2M, ...:      memory parameters
////////////////////////////////////////////////////////////////////////////

define $cpu := {
    {"edx_eax", 64},
    {"dx_ax", 32},
    {"eax", 32},
    {"ax", 16},
    {"al", 8},
    {"ah", 8},
    {"edx", 32},
    {"dx", 16},
    {"dl", 8},
    {"dh", 8},
    {"ebx", 32},
    {"bx", 16},
    {"bl", 8},
    {"bh", 8},
    {"ecx", 32},
    {"cx", 16},
    {"cl", 8},
    {"ch", 8},
    {"edi", 32},
    {"di", 16},
    {"esi", 32},
    {"si", 16},
    {"ebp", 32},
    {"bp", 16},
    {"esp", 32},
    {"sp", 16},
    {"eip", 32},
    {"ip", 16},
    {"eflags", 32},
    {"flags", 16},
    {"cs", 16},
    {"ds", 16},
    {"ss", 16},
    {"es", 16},
    {"fs", 16},
    {"gs", 16},
};

define $flags := {
    {"OF", 1},
    {"DF", 1},
    {"IF", 1},
    {"TF", 1},
    {"SF", 1},
    {"ZF", 1},
    {"AF", 1},
    {"PF", 1},
    {"CF", 1},
};

define $fpu := {
    {"st0", 80},
    {"st1", 80},
    {"st2", 80},
    {"st3", 80},
    {"st4", 80},
    {"st5", 80},
    {"st6", 80},
    {"st7", 80},
    {"control", 16},
    {"status", 16},
    {"tag", 16},
    {"instruction", 64},
    {"operand", 64},
};

define $sse := {
    {"mm0", 64},
    {"mm1", 64},
    {"mm2", 64},
    {"mm3", 64},
    {"mm4", 64},
    {"mm5", 64},
    {"mm6", 64},
    {"mm7", 64},
    {"xmm0", 128},
    {"xmm1", 128},
    {"xmm2", 128},
    {"xmm3", 128},
    {"xmm4", 128},
    {"xmm5", 128},
    {"xmm6", 128},
    {"xmm7", 128},
    {"mxcsr", 32},
};

////////////////////////////////////////////////////////////////////////////
// level 0

level(0) pattern {
    asm nop;
} code {
}

level(0) pattern {
    asm nop $0;
} code {
}

level(0) pattern {
    asm push $0;
    asm pop $0;
} code {
}

level(0) pattern {
    asm push $0;
    asm push $1;
    asm pop $1;
    asm pop $0;
} code {
}

level(0) pattern {
    asm push $0;
    asm push $1;
    asm push $2;
    asm pop $2;
    asm pop $1;
    asm pop $0;
} code {
}

level(0) pattern {
    asm push $0;
    asm push $1;
    asm push $2;
    asm push $3;
    asm pop $3;
    asm pop $2;
    asm pop $1;
    asm pop $0;
} code {
}

level(0) pattern {
    asm push $0;
    asm pop $1;
} code {
    asm mov $1, $0;
}

level(0) pattern {
    asm push $0;
    asm push $1;
    asm pop $2;
    asm pop $3;
} code {
    asm mov $2, $1;
    asm mov $3, $0;
}

level(0) pattern {
    asm push $0;
    asm push $1;
    asm push $2;
    asm pop $3;
    asm pop $4;
    asm pop $5;
} code {
    asm mov $3, $2;
    asm mov $4, $1;
    asm mov $5, $0;
}

level(0) pattern {
    asm push $0;
    asm push $1;
    asm push $2;
    asm push $3;
    asm pop $4;
    asm pop $5;
    asm pop $6;
    asm pop $7;
} code {
    asm mov $4, $3;
    asm mov $5, $2;
    asm mov $6, $1;
    asm mov $7, $0;
}

level(0) pattern {
    asm push $0;
    asm push $1;
    asm push $2;
    asm push $3;
    asm push $4;
    asm pop $5;
    asm pop $6;
    asm pop $7;
    asm pop $8;
    asm pop $9;
} code {
    asm mov $5, $4;
    asm mov $6, $3;
    asm mov $7, $2;
    asm mov $8, $1;
    asm mov $9, $0;
}

level(0) pattern {
    asm push $0;
    asm push $1;
    asm push $2;
    asm push $3;
    asm push $4;
    asm push $5;
    asm pop $6;
    asm pop $7;
    asm pop $8;
    asm pop $9;
    asm pop $10;
    asm pop $11;
} code {
    asm mov $6, $5;
    asm mov $7, $4;
    asm mov $8, $3;
    asm mov $9, $2;
    asm mov $10, $1;
    asm mov $11, $0;
}

level(0) pattern {
    asm cdq;
    asm xor eax, edx;
    asm sub eax, edx;
} code {
    renew $cpu.eax as v1;
    commit v1;
    renew v1 as v2;
    v2.svalue := $fn.abs(v1.svalue);
    commit v2;
    renew $cpu.edx as v3;
    v3.value := unknown;
    commit v3;
    update $cpu.eax;
    update $cpu.edx;
}

level(0) pattern {
    asm push ebp;
    asm mov ebp, esp;
    asm sub esp, $0;
} code {
    enter $0, 0;
}

level(0) pattern {
    asm push ebp;
    asm mov ebp, esp;
} code {
    enter 0, 0;
}

level(0) pattern {
    asm mov esp, ebp;
    asm pop ebp;
} code {
    leave;
}

level(0) pattern {
    asm enter $0, $1;
} code {
    enter $0, $1;
}

level(0) pattern {
    asm leave;
} code {
    leave;
}

level(0) pattern {
    asm xor $0, $0;
    asm not $0;
} code {
    static if ($0.bits == 32) {
        renew $0 as v1;
        v1.svalue := -1, v1.uvalue := 0xFFFFFFFF;
        commit v1;
        assert(v1.uvalue == 0xFFFFFFFF);
        assert(v1.svalue == -1);
    } else static if ($0.bits == 16) {
        renew $0 as v2;
        v2.svalue := -1, v2.uvalue := 0xFFFF;
        commit v2;
        assert(v2.uvalue == 0xFFFF);
        assert(v2.svalue == -1);
    } else static if ($0.bits == 8) {
        renew $0 as v3;
        v3.svalue := -1, v3.uvalue := 0xFF;
        commit v3;
        assert(v3.uvalue == 0xFF);
        assert(v3.svalue == -1);
    } else {
        assert(0);
    }
    update $0;
}

level(0) pattern {
    asm xor $0, $0;
    asm inc $0;
} code {
    renew $0 as v1;
    v1.value := 1;
    commit v1;
    $flags.OF := 0;
    $flags.SF := 0;
    $flags.ZF := 0;
    $flags.AF := unknown;
    $flags.PF := unknown;
    assert(v1.uvalue == 1);
    assert(v1.svalue == 1);
    update $0;
}

level(0) pattern {
    asm xor $0, $0;
    asm dec $0;
} code {
    static if ($0.bits == 32) {
        renew $0 as v1;
        v1.uvalue := 0xFFFFFFFF, v1.svalue := -1;
        commit v1;
        assert(v1.uvalue == 0xFFFFFFFF);
        assert(v1.svalue == -1);
    } else static if ($0.bits == 16) {
        renew $0 as v2;
        v2.uvalue := 0xFFFF, v2.svalue := -1;
        commit v2;
        assert(v2.uvalue == 0xFFFFFFFF);
        assert(v2.svalue == -1);
    } else static if ($0.bits == 8) {
        renew $0 as v3;
        v3.uvalue := 0xFF, v3.svalue := -1;
        commit v3;
        assert(v3.uvalue == 0xFFFFFFFF);
        assert(v3.svalue == -1);
    } else {
        assert(0);
    }
    $flags.OF := 0;
    $flags.SF := 1;
    $flags.ZF := 0;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

level(0) pattern {
    asm mov $0, $0;
} code {
}

level(0) pattern {
    asm movnti $0, $0;
} code {
}

level(0) pattern {
    asm movnti $0, $1;
} code {
    asm mov $0, $1;
}

level(0) pattern {
    asm lea $0R, [$0R];
} code {
}

level(0) pattern {
    asm lea $0R, [$0R+$1N];
} code {
    asm addnf $0R, $1N;      // CodeReverse extension
}

level(0) pattern {
    asm lea $0R, [$0R-$1N];
} code {
    asm subnf $0R, $1N;      // CodeReverse extension
}

level(0) pattern {
    asm shl $0, 1;
    asm shl $0, 1;
    asm shl $0, 1;
    asm shl $0, 1;
    asm shl $0, 1;
} code {
    asm shl $0, 5;
}

level(0) pattern {
    asm shl $0, 1;
    asm shl $0, 1;
    asm shl $0, 1;
    asm shl $0, 1;
} code {
    asm shl $0, 4;
}

level(0) pattern {
    asm shl $0, 1;
    asm shl $0, 1;
    asm shl $0, 1;
} code {
    asm shl $0, 3;
}

level(0) pattern {
    asm shl $0, 1;
    asm shl $0, 1;
} code {
    asm shl $0, 2;
}

level(0) pattern {
    asm shr $0, 1;
    asm shr $0, 1;
    asm shr $0, 1;
    asm shr $0, 1;
    asm shr $0, 1;
} code {
    asm shr $0, 5;
}

level(0) pattern {
    asm shr $0, 1;
    asm shr $0, 1;
    asm shr $0, 1;
    asm shr $0, 1;
} code {
    asm shr $0, 4;
}

level(0) pattern {
    asm shr $0, 1;
    asm shr $0, 1;
    asm shr $0, 1;
} code {
    asm shr $0, 3;
}

level(0) pattern {
    asm shr $0, 1;
    asm shr $0, 1;
} code {
    asm shr $0, 2;
}

level(0) pattern {
    asm sal $0, 1;
    asm sal $0, 1;
    asm sal $0, 1;
    asm sal $0, 1;
    asm sal $0, 1;
} code {
    asm sal $0, 5;
}

level(0) pattern {
    asm sal $0, 1;
    asm sal $0, 1;
    asm sal $0, 1;
    asm sal $0, 1;
} code {
    asm sal $0, 4;
}

level(0) pattern {
    asm sal $0, 1;
    asm sal $0, 1;
    asm sal $0, 1;
} code {
    asm sal $0, 3;
}

level(0) pattern {
    asm sal $0, 1;
    asm sal $0, 1;
} code {
    asm sal $0, 2;
}

level(0) pattern {
    asm sar $0, 1;
    asm sar $0, 1;
    asm sar $0, 1;
    asm sar $0, 1;
    asm sar $0, 1;
} code {
    asm sar $0, 5;
}

level(0) pattern {
    asm sar $0, 1;
    asm sar $0, 1;
    asm sar $0, 1;
    asm sar $0, 1;
} code {
    asm sar $0, 4;
}

level(0) pattern {
    asm sar $0, 1;
    asm sar $0, 1;
    asm sar $0, 1;
} code {
    asm sar $0, 3;
}

level(0) pattern {
    asm sar $0, 1;
    asm sar $0, 1;
} code {
    asm sar $0, 2;
}

level(0) pattern {
    asm jmp $label.1;
$label.1:
} code {
$label.1:
}

////////////////////////////////////////////////////////////////////////////
// level 1

// strlen #0
level(1) pattern {
    asm repne_scasb;
    asm not ecx;
    asm lea $0, [ecx-1];
} code {
    if ($cpu.al.value == 0 && 
        ($cpu.ecx.svalue == -1 || $cpu.ecx.uvalue == 0xFFFFFFFF))
    {
        renew $cpu.edi as v1;
        v1.type := $type.ptr($type.s8);
        commit v1;
        renew $0 as v2;
        v2.uvalue := $fn.strlen(v1.pvalue);
        commit v2;
        renew v1 as v3;
        v3.pvalue := v1.pvalue + v2.uvalue;
        commit v3;
        renew $cpu.ecx as v4;
        v4.value := unknown;
        commit v4;
    } else {
        asm repne_scasb;
        renew $cpu.ecx as v5;
        commit v5;
        renew v5 as v6;
        v6.uvalue := ~v5.uvalue;
        commit v6;
        renew $cpu.ecx as v7;
        commit v7;
        renew $0 as v8;
        v8.value := v7.value - 1;
        commit v8;
    }
    update $cpu.ecx;
    update $0;
}

// wcslen #0
level(1) pattern {
    asm lea $0, [ecx+0x2];
$label.1:
    asm mov cx, [eax];
    asm addnf ecx, 2;
    asm test cx, cx;
    asm jnz $label.1;
    asm sub ecx, $0;
    asm sar ecx, 1;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    renew v1 as v2;
    v2.uvalue := $fn.wcslen(v1.pvalue);
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    assert($cpu.cl.value == 0);
    assert($cpu.ch.value == 0);
    assert($cpu.cx.value == 0);
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcslen #1
level(1) pattern {
    asm lea $0, [ecx+0x2];
$label.1:
    asm mov cx, [eax];
    asm addnf ecx, 2;
    asm test cx, cx;
    asm jnz $label.1;
    asm sub ecx, $0;
    asm shr ecx, 1;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    renew v1 as v2;
    v2.uvalue := $fn.wcslen(v1.pvalue);
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcslen #2
level(1) pattern {
    asm lea $0, [ecx+0x2];
$label.1:
    asm mov cx, [eax];
    asm add ecx, 2;
    asm test cx, cx;
    asm jnz $label.1;
    asm sub ecx, $0;
    asm sar ecx, 1;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    renew v1 as v2;
    v2.uvalue := $fn.wcslen(v1.pvalue);
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcslen #3
level(1) pattern {
    asm lea $0, [ecx+0x2];
$label.1:
    asm mov cx, [eax];
    asm add ecx, 2;
    asm test cx, cx;
    asm jnz $label.1;
    asm sub ecx, $0;
    asm shr ecx, 1;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    renew v1 as v2;
    v2.uvalue := $fn.wcslen(v1.pvalue);
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcslen #4
level(1) pattern {
    asm lea $0, [ecx+0x2];
$label.1:
    asm mov cx, [eax];
    asm inc ecx;
    asm inc ecx;
    asm test cx, cx;
    asm jnz $label.1;
    asm sub ecx, $0;
    asm sar ecx, 1;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    renew v1 as v2;
    v2.uvalue := $fn.wcslen(v1.pvalue);
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcslen #5
level(1) pattern {
    asm lea $0, [ecx+0x2];
$label.1:
    asm mov cx, [eax];
    asm inc ecx;
    asm inc ecx;
    asm test cx, cx;
    asm jnz $label.1;
    asm sub ecx, $0;
    asm shr ecx, 1;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    renew v1 as v2;
    v2.uvalue := $fn.wcslen(v1.pvalue);
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcslen * 2 #0
level(1) pattern {
    asm lea $0, [ecx+0x2];
$label.1:
    asm mov cx, [eax];
    asm addnf ecx, 2;
    asm test cx, cx;
    asm jnz $label.1;
    asm sub ecx, $0;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    renew v1 as v2;
    v2.uvalue := $fn.wcslen(v1.pvalue) * 2;
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcslen * 2 #1
level(1) pattern {
    asm lea $0, [ecx+0x2];
$label.1:
    asm mov cx, [eax];
    asm add ecx, 2;
    asm test cx, cx;
    asm jnz $label.1;
    asm sub ecx, $0;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    renew v1 as v2;
    v2.uvalue := $fn.wcslen(v1.pvalue) * 2;
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcslen * 2 #2
level(1) pattern {
    asm lea $0, [ecx+0x2];
$label.1:
    asm mov cx, [eax];
    asm inc ecx;
    asm inc ecx;
    asm test cx, cx;
    asm jnz $label.1;
    asm sub ecx, $0;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    renew v1 as v2;
    v2.uvalue := $fn.wcslen(v1.pvalue) * 2;
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcslen * 2 #3
level(1) pattern {
    asm lea $0, [ecx+0x2];
$label.1:
    asm mov cx, [eax];
    asm inc ecx;
    asm inc ecx;
    asm test cx, cx;
    asm jnz $label.1;
    asm sub ecx, $0;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    renew v1 as v2;
    v2.uvalue := $fn.wcslen(v1.pvalue) * 2;
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// ptr + wcslen * 2 #0
level(1) pattern {
    asm lea $0, [ecx+0x2];
$label.1:
    asm mov cx, [eax];
    asm addnf ecx, 2;
    asm test cx, cx;
    asm jnz $label.1;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    renew v1 as v2;
    v2.pvalue := v1.pvalue + $fn.wcslen(v1.pvalue) * 2;
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// ptr + wcslen * 2 #1
level(1) pattern {
    asm lea $0, [ecx+0x2];
$label.1:
    asm mov cx, [eax];
    asm add ecx, 2;
    asm test cx, cx;
    asm jnz $label.1;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    renew v1 as v2;
    v2.pvalue := v1.pvalue + $fn.wcslen(v1.pvalue) * 2;
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// ptr + wcslen * 2 #2
level(1) pattern {
    asm lea $0, [ecx+0x2];
$label.1:
    asm mov cx, [eax];
    asm inc ecx;
    asm inc ecx;
    asm test cx, cx;
    asm jnz $label.1;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    renew v1 as v2;
    v2.pvalue := v1.pvalue + $fn.wcslen(v1.pvalue) * 2;
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// ptr + wcslen * 2 #3
level(1) pattern {
    asm lea $0, [ecx+0x2];
$label.1:
    asm mov cx, [eax];
    asm inc ecx;
    asm inc ecx;
    asm test cx, cx;
    asm jnz $label.1;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    renew v1 as v2;
    v2.pvalue := v1.pvalue + $fn.wcslen(v1.pvalue) * 2;
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcscpy #0
level(1) pattern {
    asm sub $0R, ecx;
$label.1:
    asm movzx rcx, [ecx];
    asm addnf ecx, 2;
    asm mov [$0R+ecx-0x2], cx;
    asm test cx, cx;
    asm jnz $label.1;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    renew $0R as v2;
    commit v2;
    $fn.wcscpy(v2.pvalue, v1.pvalue);
    renew $cpu.cx as v3;
    v3.uvalue := 0;
    commit v3;
    renew $0R as v4;
    v4.value := unknown;
    commit v4;
    update $0R;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcscpy #1
level(1) pattern {
    asm sub $0R, ecx;
$label.1:
    asm movzx rcx, [ecx];
    asm add ecx, 0x2;
    asm mov [$0R+ecx-0x2], cx;
    asm test cx, cx;
    asm jnz $label.1;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    renew $0R as v2;
    commit v2;
    $fn.wcscpy(v2.pvalue, v1.pvalue);
    renew $cpu.cx as v3;
    v3.uvalue := 0;
    commit v3;
    renew $0R as v4;
    v4.value := unknown;
    commit v4;
    update $0R;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcscpy #2
level(1) pattern {
    asm sub $0R, ecx;
$label.1:
    asm movzx rcx, [ecx];
    asm inc ecx;
    asm inc ecx;
    asm mov [$0R+ecx-0x2], cx;
    asm test cx, cx;
    asm jnz $label.1;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    renew $0R as v2;
    commit v2;
    $fn.wcscpy(v2.pvalue, v1.pvalue);
    renew $cpu.cx as v3;
    v3.uvalue := 0;
    commit v3;
    renew $0R as v4;
    v4.value := unknown;
    commit v4;
    update $0R;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcscpy #3
level(1) pattern {
    asm sub $0R, ecx;
$label.1:
    asm movzx rcx, [ecx];
    asm inc ecx;
    asm inc ecx;
    asm mov [$0R+ecx-0x2], cx;
    asm test cx, cx;
    asm jnz $label.1;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    renew $0R as v2;
    commit v2;
    $fn.wcscpy(v2.pvalue, v1.pvalue);
    renew $cpu.cx as v3;
    v3.uvalue := 0;
    commit v3;
    renew $0R as v4;
    v4.value := unknown;
    commit v4;
    update $0R;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

////////////////////////////////////////////////////////////////////////////
// level 2

level(2) pattern {
    asm xor $0, $0;
} code {
    renew $0 as v1;
    v1.value := 0;
    commit v1;
    $flags.SF := 0;
    $flags.ZF := 1;
    $flags.OF := 0;
    $flags.CF := 0;
    $flags.PF := unknown;
    $flags.AF := unknown;
    assert(v1.value == 0);
    update $0;
}

level(2) pattern {
    asm add $0, $0;
} code {
    renew $0 as v1;
    commit v1;
    renew v1 as v2;
    v2.value := v1.value * 2;
    commit v2;
    $flags.ZF := v2.value == 0;
    $flags.SF := v2.svalue < 0;
    $flags.CF := v2.uvalue < v1.uvalue;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

level(2) pattern {
    asm and $0, $0;
} code {
    renew $0 as v1;
    commit v1;
    $flags.ZF := v1.value == 0;
    $flags.SF := v1.svalue < 0;
    $flags.CF := 0;
    $flags.OF := 0;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

level(2) pattern {
    asm or $0, $0;
} code {
    renew $0 as v1;
    commit v1;
    $flags.SF := 0;
    $flags.ZF := v1.value == 0;
    $flags.OF := 0;
    $flags.CF := 0;
    $flags.PF := unknown;
    $flags.AF := unknown;
}

level(2) pattern {
    asm test $0, $0;
} code {
    renew $0 as v1;
    commit v1;
    $flags.ZF := v1.value == 0;
    $flags.SF := v1.svalue < 0;
    $flags.CF := 0;
    $flags.OF := 0;
    $flags.PF := unknown;
    $flags.AF := unknown;
}

level(2) pattern {
    asm dec $0;
    asm dec $0;
    asm dec $0;
} code {
    renew $0 as v1;
    commit v1;
    renew v1 as v2;
    v2.value := v1.value - 3;
    commit v2;
    $flags.SF := v2.svalue < 0;
    $flags.ZF := v2.value == 0;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

level(2) pattern {
    asm dec $0;
    asm dec $0;
} code {
    renew $0 as v1;
    commit v1;
    renew v1 as v2;
    v2.value := v1.value - 2;
    commit v2;
    $flags.SF := v2.svalue < 0;
    $flags.ZF := v2.value == 0;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

level(2) pattern {
    asm inc $0;
    asm inc $0;
    asm inc $0;
} code {
    renew $0 as v1;
    commit v1;
    renew v1 as v2;
    v2.value := v1.value + 3;
    commit v2;
    $flags.SF := v2.svalue < 0;
    $flags.ZF := v2.value == 0;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

level(2) pattern {
    asm inc $0;
    asm inc $0;
} code {
    renew $0 as v1;
    commit v1;
    renew v1 as v2;
    v2.value := v1.value + 2;
    commit v2;
    $flags.SF := v2.svalue < 0;
    $flags.ZF := v2.value == 0;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

level(1) pattern {
    asm sub $0R, eax;
$label.1:
    asm movzx ecx, [eax];
    asm lea eax, [eax+2];
    asm mov [$0R+eax-2], cx;
    asm test cx, cx;
    asm jnz $label.1;
} code {
    renew $cpu.eax as v1;
    commit v1;
    renew $0R as v2;
    commit v2;
    $fn.wcscpy(v2.pvalue, v1.pvalue);
    renew $cpu.cx as v3;
    v3.uvalue := 0;
    commit v3;
    renew $0R as v4;
    v4.value := unknown;
    commit v4;
    update $0R;
    $flags.SF := unknown;
    $flags.ZF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

level(1) pattern {
    asm sub $0R, eax;
$label.1:
    asm movzx ecx, [eax];
    asm add eax, 2;
    asm mov [$0R+eax-2], cx;
    asm test cx, cx;
    asm jnz $label.1;
} code {
    renew $cpu.eax as v1;
    commit v1;
    renew $0R as v2;
    commit v2;
    $fn.wcscpy(v2.pvalue, v1.pvalue);
    renew $cpu.cx as v3;
    v3.uvalue := 0;
    commit v3;
    renew $0R as v4;
    v4.value := unknown;
    commit v4;
    update $0R;
    $flags.SF := unknown;
    $flags.ZF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

level(1) pattern {
    asm sub $0R, eax;
$label.1:
    asm movzx ecx, [eax];
    asm inc eax;
    asm inc eax;
    asm mov [$0R+eax-2], cx;
    asm test cx, cx;
    asm jnz $label.1;
} code {
    renew $cpu.eax as v1;
    commit v1;
    renew $0R as v2;
    commit v2;
    $fn.wcscpy(v2.pvalue, v1.pvalue);
    renew $cpu.cx as v3;
    v3.uvalue := 0;
    commit v3;
    renew $0R as v4;
    v4.value := unknown;
    commit v4;
    update $0R;
    $flags.SF := unknown;
    $flags.ZF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

////////////////////////////////////////////////////////////////////////////
// update's

//
// updating low bytes
//

pattern {
    update $cpu.al;
} code {
    renew $cpu.al as v1;
    commit v1;
    renew $cpu.ah as v2;
    commit v2;
    renew $cpu.ax as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFF00));
    commit v3;
    update_upward $cpu.ax;
    // dx:ax
    renew $cpu.dx as v4;
    commit v4;
    renew $cpu.ax as v5;
    commit v5;
    reset $cpu.dx_ax as v6;
    v6.uvalue := (v5.uvalue | (v4.uvalue << 16));
    commit v6;
    // edx:eax
    renew $cpu.edx as v7;
    commit v7;
    renew $cpu.eax as v8;
    commit v8;
    reset $cpu.edx_eax as v9;
    v9.uvalue := (v8.uvalue | (v7.uvalue << 32));
    commit v9;
}

pattern {
    update $cpu.bl;
} code {
    renew $cpu.bl as v1;
    commit v1;
    renew $cpu.bh as v2;
    commit v2;
    renew $cpu.bx as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFF00));
    commit v3;
    update_upward $cpu.bx;
}

pattern {
    update $cpu.cl;
} code {
    renew $cpu.cl as v1;
    commit v1;
    renew $cpu.ch as v2;
    commit v2;
    renew $cpu.cx as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFF00));
    commit v3;
    update_upward $cpu.cx;
}

pattern {
    update $cpu.dl;
} code {
    renew $cpu.dl as v1;
    commit v1;
    renew $cpu.dh as v2;
    commit v2;
    renew $cpu.dx as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFF00));
    commit v3;
    update_upward $cpu.dx;
    // dx:ax
    renew $cpu.dx as v4;
    commit v4;
    renew $cpu.ax as v5;
    commit v5;
    reset $cpu.dx_ax as v6;
    v6.uvalue := (v5.uvalue | (v4.uvalue << 16));
    commit v6;
    // edx:eax
    renew $cpu.edx as v7;
    commit v7;
    renew $cpu.eax as v8;
    commit v8;
    reset $cpu.edx_eax as v9;
    v9.uvalue := (v8.uvalue | (v7.uvalue << 32));
    commit v9;
}

//
// updating high bytes
//

pattern {
    update $cpu.ah;
} code {
    renew $cpu.al as v1;
    commit v1;
    renew $cpu.ah as v2;
    commit v2;
    renew $cpu.ax as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue << 8));
    commit v3;
    update_upward $cpu.ax;
    //
    renew $cpu.dx as v4;
    commit v4;
    renew $cpu.ax as v5;
    commit v5;
    reset $cpu.dx_ax as v6;
    v6.uvalue := (v5.uvalue | (v4.uvalue << 16));
    commit v6;
    //
    renew $cpu.edx as v7;
    commit v7;
    renew $cpu.eax as v8;
    commit v8;
    reset $cpu.edx_eax as v9;
    v9.uvalue := (v8.uvalue | (v7.uvalue << 32));
    commit v9;
}

pattern {
    update $cpu.bh;
} code {
    renew $cpu.bl as v1;
    commit v1;
    renew $cpu.bh as v2;
    commit v2;
    renew $cpu.bx as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue << 8));
    commit v3;
    update_upward $cpu.bx;
}

pattern {
    update $cpu.ch;
} code {
    renew $cpu.cl as v1;
    commit v1;
    renew $cpu.ch as v2;
    commit v2;
    renew $cpu.cx as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue << 8));
    commit v3;
    update_upward $cpu.cx;
}

pattern {
    update $cpu.dh;
} code {
    renew $cpu.dl as v1;
    commit v1;
    renew $cpu.dh as v2;
    commit v2;
    renew $cpu.dx as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue << 8));
    commit v3;
    update_upward $cpu.dx;
    // dx:ax
    renew $cpu.dx as v4;
    commit v4;
    renew $cpu.ax as v5;
    commit v5;
    reset $cpu.dx_ax as v6;
    v6.uvalue := (v5.uvalue | (v4.uvalue << 16));
    commit v6;
    // edx:eax
    renew $cpu.edx as v7;
    commit v7;
    renew $cpu.eax as v8;
    commit v8;
    reset $cpu.edx_eax as v9;
    v9.uvalue := (v8.uvalue | (v7.uvalue << 32));
    commit v9;
}

//
// updating words upward
//

pattern {
    update_upward $cpu.ax;
} code {
    renew $cpu.ax as v1;
    commit v1;
    renew $cpu.eax as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFF0000));
    commit v3;
}

pattern {
    update_upward $cpu.bx;
} code {
    renew $cpu.bx as v1;
    commit v1;
    renew $cpu.ebx as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFF0000));
    commit v3;
}

pattern {
    update_upward $cpu.cx;
} code {
    renew $cpu.cx as v1;
    commit v1;
    renew $cpu.ecx as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFF0000));
    commit v3;
}

pattern {
    update_upward $cpu.dx;
} code {
    renew $cpu.dx as v1;
    commit v1;
    renew $cpu.edx as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFF0000));
    commit v3;
}

pattern {
    update_upward $cpu.di;
} code {
    renew $cpu.di as v1;
    commit v1;
    renew $cpu.edi as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFF0000));
    commit v3;
}

pattern {
    update_upward $cpu.si;
} code {
    renew $cpu.si as v1;
    commit v1;
    renew $cpu.esi as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFF0000));
    commit v3;
}

pattern {
    update_upward $cpu.bp;
} code {
    renew $cpu.bp as v1;
    commit v1;
    renew $cpu.ebp as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFF0000));
    commit v3;
}

pattern {
    update_upward $cpu.sp;
} code {
    renew $cpu.sp as v1;
    commit v1;
    renew $cpu.esp as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFF0000));
    commit v3;
}

//
// updating words downward
//

pattern {
    update_downward $cpu.ax;
} code {
    renew $cpu.ax as v1;
    commit v1;
    renew $cpu.al as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    renew $cpu.ah as v3;
    v3.uvalue := (v1.uvalue >> 8) & 0xFF;
    commit v3;
}

pattern {
    update_downward $cpu.bx;
} code {
    renew $cpu.bx as v1;
    commit v1;
    renew $cpu.bl as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    renew $cpu.bh as v3;
    v3.uvalue := (v1.uvalue >> 8) & 0xFF;
    commit v3;
}

pattern {
    update_downward $cpu.cx;
} code {
    renew $cpu.cx as v1;
    commit v1;
    renew $cpu.cl as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    renew $cpu.ch as v3;
    v3.uvalue := (v1.uvalue >> 8) & 0xFF;
    commit v3;
}

pattern {
    update_downward $cpu.dx;
} code {
    renew $cpu.dx as v1;
    commit v1;
    renew $cpu.dl as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    renew $cpu.dh as v3;
    v3.uvalue := (v1.uvalue >> 8) & 0xFF;
    commit v3;
}

//
// updating words
//

pattern {
    update $cpu.ax;
} code {
    update_downward $cpu.ax;
    update_upward $cpu.ax;
    // dx:ax
    renew $cpu.dx as v1;
    commit v1;
    renew $cpu.ax as v2;
    commit v2;
    reset $cpu.dx_ax as v3;
    v3.uvalue := (v2.uvalue | (v1.uvalue << 16));
    commit v3;
    // edx:eax
    renew $cpu.edx as v4;
    commit v4;
    renew $cpu.eax as v5;
    commit v5;
    reset $cpu.edx_eax as v6;
    v6.uvalue := (v5.uvalue | (v4.uvalue << 32));
    commit v6;
}

pattern {
    update $cpu.bx;
} code {
    update_downward $cpu.bx;
    update_upward $cpu.bx;
}

pattern {
    update $cpu.cx;
} code {
    update_downward $cpu.cx;
    update_upward $cpu.cx;
}

pattern {
    update $cpu.dx;
} code {
    update_downward $cpu.dx;
    update_upward $cpu.dx;
    // dx:ax
    renew $cpu.dx as v1;
    commit v1;
    renew $cpu.ax as v2;
    commit v2;
    reset $cpu.dx_ax as v3;
    v3.uvalue := (v2.uvalue | (v1.uvalue << 16));
    commit v3;
    // edx:eax
    renew $cpu.edx as v4;
    commit v4;
    renew $cpu.eax as v5;
    commit v5;
    reset $cpu.edx_eax as v6;
    v6.uvalue := (v5.uvalue | (v4.uvalue << 32));
    commit v6;
}

pattern {
    update $cpu.di;
} code {
    update_upward $cpu.di;
}

pattern {
    update $cpu.si;
} code {
    update_upward $cpu.si;
}

pattern {
    update $cpu.bp;
} code {
    update_upward $cpu.bp;
}

pattern {
    update $cpu.sp;
} code {
    update_upward $cpu.sp;
}

//
// updating dwords downward
//

pattern {
    update_downward $cpu.eax;
} code {
    renew $cpu.eax as v1;
    commit v1;
    renew $cpu.ax as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.ax;
}

pattern {
    update_downward $cpu.ebx;
} code {
    renew $cpu.ebx as v1;
    commit v1;
    renew $cpu.bx as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.bx;
}

pattern {
    update_downward $cpu.ecx;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    renew $cpu.cx as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.cx;
}

pattern {
    update_downward $cpu.edx;
} code {
    renew $cpu.edx as v1;
    commit v1;
    renew $cpu.dx as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.dx;
}

pattern {
    update_downward $cpu.edi;
} code {
    renew $cpu.edi as v1;
    commit v1;
    renew $cpu.di as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.di;
}

pattern {
    update_downward $cpu.esi;
} code {
    renew $cpu.esi as v1;
    commit v1;
    renew $cpu.si as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.si;
}

pattern {
    update_downward $cpu.ebp;
} code {
    renew $cpu.ebp as v1;
    commit v1;
    renew $cpu.bp as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.bp;
}

pattern {
    update_downward $cpu.esp;
} code {
    renew $cpu.esp as v1;
    commit v1;
    renew $cpu.sp as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.sp;
}

pattern {
    update_downward $cpu.r8d;
} code {
    renew $cpu.r8d as v1;
    commit v1;
    renew $cpu.r8w as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.r8w;
}

pattern {
    update_downward $cpu.r9d;
} code {
    renew $cpu.r9d as v1;
    commit v1;
    renew $cpu.r9w as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.r9w;
}

pattern {
    update_downward $cpu.r10d;
} code {
    renew $cpu.r10d as v1;
    commit v1;
    renew $cpu.r10w as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.r10w;
}

pattern {
    update_downward $cpu.r11d;
} code {
    renew $cpu.r11d as v1;
    commit v1;
    renew $cpu.r11w as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.r11w;
}

pattern {
    update_downward $cpu.r12d;
} code {
    renew $cpu.r12d as v1;
    commit v1;
    renew $cpu.r12w as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.r12w;
}

pattern {
    update_downward $cpu.r13d;
} code {
    renew $cpu.r13d as v1;
    commit v1;
    renew $cpu.r13w as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.r13w;
}

pattern {
    update_downward $cpu.r14d;
} code {
    renew $cpu.r14d as v1;
    commit v1;
    renew $cpu.r14w as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.r14w;
}

pattern {
    update_downward $cpu.r15d;
} code {
    renew $cpu.r15d as v1;
    commit v1;
    renew $cpu.r15w as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.r15w;
}

pattern {
    update_downward $cpu.esp;
} code {
    renew $cpu.esp as v1;
    commit v1;
    renew $cpu.sp as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.sp;
}

pattern {
    update_downward $cpu.eip;
} code {
    renew $cpu.eip as v1;
    commit v1;
    renew $cpu.ip as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.ip;
}

pattern {
    update_downward $cpu.eflags;
} code {
    renew $cpu.eflags as v1;
    commit v1;
    renew $cpu.flags as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
}

//
// updating dwords
//

pattern {
    update $cpu.eax;
} code {
    update_downward $cpu.eax;
    // dx:ax
    renew $cpu.dx as v1;
    commit v1;
    renew $cpu.ax as v2;
    commit v2;
    reset $cpu.dx_ax as v3;
    v3.uvalue := (v2.uvalue | (v1.uvalue << 16));
    commit v3;
    // edx:eax
    renew $cpu.edx as v4;
    commit v4;
    renew $cpu.eax as v5;
    commit v5;
    reset $cpu.edx_eax as v6;
    v6.uvalue := (v5.uvalue | (v4.uvalue << 32));
    commit v6;
}

pattern {
    update $cpu.ebx;
} code {
    update_downward $cpu.ebx;
}

pattern {
    update $cpu.ecx;
} code {
    update_downward $cpu.ecx;
}

pattern {
    update $cpu.edx;
} code {
    update_downward $cpu.edx;
    // dx:ax
    renew $cpu.dx as v1;
    commit v1;
    renew $cpu.ax as v2;
    commit v2;
    reset $cpu.dx_ax as v3;
    v3.uvalue := (v2.uvalue | (v1.uvalue << 16));
    commit v3;
    // edx:eax
    renew $cpu.edx as v4;
    commit v4;
    renew $cpu.eax as v5;
    commit v5;
    reset $cpu.edx_eax as v6;
    v6.uvalue := (v5.uvalue | (v4.uvalue << 32));
    commit v6;
}

pattern {
    update $cpu.edi;
} code {
    update_downward $cpu.edi;
}

pattern {
    update $cpu.esi;
} code {
    update_downward $cpu.esi;
}

pattern {
    update $cpu.ebp;
} code {
    update_downward $cpu.ebp;
}

pattern {
    update $cpu.esp;
} code {
    update_downward $cpu.esp;
}

pattern {
    update $cpu.esp;
} code {
    update_downward $cpu.esp;
}

pattern {
    update $cpu.eip;
} code {
    update_downward $cpu.eip;
}

pattern {
    update $cpu.eflags;
} code {
    update_downward $cpu.eflags;
}

//
//
//
pattern {
    update $cpu.edx, $cpu.eax;
} code {
    update_downward $cpu.edx;
    update_downward $cpu.eax;
    renew $cpu.dx as v1;
    commit v1;
    renew $cpu.ax as v2;
    commit v2;
    renew $cpu.dx_ax as v3;
    v3.uvalue := (v2.uvalue | (v1.uvalue << 16));
    commit v3;
    renew $cpu.edx as v4;
    commit v4;
    renew $cpu.eax as v5;
    commit v5;
    renew $cpu.edx_eax as v6;
    v6.uvalue := (v5.uvalue | (v4.uvalue << 32));
    commit v6;
}

pattern {
    update $cpu.dx, $cpu.ax;
} code {
    update_downward $cpu.dx;
    update_downward $cpu.ax;
    update_upward $cpu.dx;
    update_upward $cpu.ax;
    renew $cpu.dx as v1;
    commit v1;
    renew $cpu.ax as v2;
    commit v2;
    renew $cpu.dx_ax as v3;
    v3.uvalue := (v2.uvalue | (v1.uvalue << 16));
    commit v3;
    renew $cpu.edx as v4;
    commit v4;
    renew $cpu.eax as v5;
    commit v5;
    renew $cpu.edx_eax as v6;
    v6.uvalue := (v5.uvalue | (v4.uvalue << 32));
    commit v6;
}

pattern {
    update $0M;
} code {
    static if ($0M.bits == 64) {
        continuous $1M.addr, $1M.addr + 8;
    } else static if ($0M.bits == 32) {
        continuous $1M.addr, $1M.addr + 4;
    } else static if ($0M.bits == 16) {
        continuous $1M.addr, $1M.addr + 2;
    } else static if ($0M.bits == 8) {
        continuous $1M.addr, $1M.addr + 1;
    } else {
        assert(0);
    }
}

////////////////////////////////////////////////////////////////////////////
// instructions

pattern {
    asm aaa;
} code {
    renew $cpu.al as v1;
    commit v1;
    renew $cpu.ah as v2;
    commit v2;
    new v3;
    v3.bits := 32;
    v3.value := (v1.value & 0x0F) >= 10 || $flags.AF == 1;
    commit v3;
    if (v3.value) {
        renew v1 as v4;
        v4.value := (v1.value + 6) & 0x0F;
        commit v4;
        renew v2 as v5;
        v5.value := v2.value + 1;
        commit v5;
        $flags.AF := 1;
        $flags.CF := 1;
    } else {
        renew v1 as v6;
        v6.value := (v1.value & 0x0F);
        commit v6;
        $flags.AF := 0;
        $flags.CF := 0;
    }
    $flags.OF := unknown;
    $flags.SF := unknown;
    $flags.ZF := unknown;
    $flags.PF := unknown;
    update $cpu.al, $cpu.ah;
}

pattern {
    asm aad;
} code {
    renew $cpu.al as v1;
    commit v1;
    renew $cpu.ah as v2;
    commit v2;
    renew v1 as v3;
    v3.value := v1.value + v2.value * 10;
    commit v3;
    renew v2 as v4;
    v4.value := 0;
    commit v4;
    assert($cpu.ah.value == 0);
    $flags.ZF := v3.value == 0;
    $flags.SF := v3.svalue < 0;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.CF := unknown;
    update $cpu.al, $cpu.ah;
}

pattern {
    asm aam;
} code {
    asm aam 10;
}

pattern {
    asm aam $0;
} code {
    renew $cpu.ah as v1;
    commit v1;
    renew $cpu.al as v2;
    commit v2;
    renew v1 as v3;
    v3.value := v1.value / $0.value;
    commit v3;
    renew v2 as v4;
    v4.value := v1.value % $0.value;
    commit v4;
    $flags.ZF := v4.value == 0;
    $flags.SF := v4.svalue < 0;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.CF := unknown;
    update $cpu.al, $cpu.ah;
}

pattern {
    asm aas;
} code {
    renew $cpu.ah as v1;
    commit v1;
    renew $cpu.al as v2;
    commit v2;
    new v3;
    v3.bits := 32;
    v3.value := (v2.value & 0F) >= 10 || $flags.AF == 1;
    commit v3;
    if (v3.value) {
        renew v2 as v4;
        v4.value := ((v2.value - 6) & 0x0F);
        commit v4;
        renew v1 as v5;
        v5.value := v1.value - 1;
        commit v5;
        $flags.AF := 1;
        $flags.CF := 1;
    } else {
        renew v2 as v6;
        v6.value := (v1.value & 0x0F);
        commit v6;
        $flags.AF := 0;
        $flags.CF := 0;
    }
    $flags.OF := unknown;
    $flags.SF := unknown;
    $flags.ZF := unknown;
    $flags.PF := unknown;
    update $cpu.al, $cpu.ah;
}

pattern {
    asm adc $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.value := v1.value + v2.value + $flags.CF;
    commit v3;
    $flags.ZF := v3.value == 0;
    $flags.SF := v3.svalue < 0;
    $flags.CF := v3.uvalue < v1.uvalue;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

pattern {
    add $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.value := v1.value + v2.value;
    commit v3;
    $flags.ZF := v3.value == 0;
    $flags.SF := v3.svalue < 0;
    $flags.CF := v3.uvalue < v1.uvalue;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

pattern {
    addnf $0, $1;   // CodeReverse extension
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.value := v1.value + v2.value;
    commit v3;
    update $0;
}

pattern {
    asm and $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.value := (v1.value & v2.value);
    commit v3;
    $flags.ZF := v3.value == 0;
    $flags.SF := v3.svalue < 0;
    $flags.CF := 0;
    $flags.OF := 0;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

// arpl($dest, $src);
// bound($dest, $src);

pattern {
    asm bswap $0;
} code {
    renew $0 as v1;
    commit v1;
    renew v1 as v2;
    v2.value := $fn._bswap(v1.value);
    commit v2;
    update $0;
}

pattern {
    asm bt $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.value := (v1.value & (1 << v2.value));
    commit v3;
    $flags.CF := v3.value != 0;
    $flags.OF := unknown;
    $flags.SF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

pattern {
    asm btc $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.value := (v1.value & (1 << v2.value));
    commit v3;
    $flags.CF := v3.value != 0;
    if (v3.value) {
        renew v1 as v2;
        v2.value := v1.value & ~(1 << $1.value);
        commit v2;
    } else {
        renew v1 as v3;
        v3.value := v1.value | (1 << $1.value);
        commit v3;
    }
    $flags.OF := unknown;
    $flags.SF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

pattern {
    asm btr $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.value := (v1.value & (1 << v2.value));
    commit v3;
    $flags.CF := v3.value != 0;
    new v3 as v4;
    v4.value := (v1.value & ~(1 << $1.value));
    commit v2;
    $flags.OF := unknown;
    $flags.SF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

pattern {
    asm bts $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.value := (v1.value & (1 << v2.value));
    commit v3;
    $flags.CF := v3.value != 0;
    new v3 as v4;
    v4.value := (v1.value | (1 << v2.value));
    commit v4;
    $flags.OF := unknown;
    $flags.SF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

pattern {
    asm call $0;
} code {
    renew $0 as v1;
    commit v1;
    call v1.cvalue;
}

pattern {
    asm cbw;
} code {
    renew $cpu.al as v1;
    commit v1;
    renew $cpu.ax as v2;
    v2.svalue := v1.svalue;
    commit v2;
    update $cpu.ax;
}

pattern {
    asm cwde;
} code {
    renew $cpu.ax as v1;
    commit v1;
    renew $cpu.eax as v2;
    v2.svalue := v1.svalue;
    commit v2;
    update $cpu.eax;
}

pattern {
    asm clc
} code {
    $flags.CF := 0;
}

pattern {
    asm cld;
} code {
    $flags.DF := 0;
}

// clflush($m8);

pattern {
    asm cli;
} code {
    $flags.IF := 0;
}

// clts();

pattern {
    asm cmc;
} code {
    if ($flags.CF == 1) {
        $flags.CF := 0;
    } else {
        $flags.CF := 1;
    }
}

pattern {
    asm cmova $0, $1;
} code {
    if ($flags.CF == 0 && $flags.ZF == 0)) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovae $0, $1;
} code {
    if ($flags.CF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovb $0, $1;
} code {
    if ($flags.CF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovbe $0, $1;
} code {
    if ($flags.CF == 1 || flags.ZF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovc $0, $1;
} code {
    if ($flags.CF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmove $0, $1;
} code {
    if ($flags.ZF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovg $0, $1;
} code {
    if ($flags.ZF == 0 && $flags.SFeqOF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovge $0, $1;
} code {
    if ($flags.SFeqOF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovl $0, $1;
} code {
    if ($flags.SFeqOF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovle $0, $1;
} code {
    if ($flags.ZF == 1 || $flags.SFeqOF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovna $0, $1;
} code {
    if ($flags.CF == 1 || $flags.ZF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovnae $0, $1;
} code {
    if ($flags.CF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    cmovnb $0, $1;
} code {
    if ($flags.CF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovnbe $0, $1;
} code {
    if ($flags.CF == 0 && $flags.ZF == 0)) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovnc $0, $1;
} code {
    if ($flags.CF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovne $0, $1;
} code {
    if ($flags.ZF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovng $0, $1;
} code {
    if ($flags.ZF == 1 || $flags.SFeqOF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovnge $0, $1;
} code {
    if ($flags.SFeqOF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovnl $0, $1;
} code {
    if ($flags.SFeqOF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovnle $0, $1;
} code {
    if ($flags.ZF == 0 && $flags.SFeqOF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovno $0, $1;
} code {
    if ($flags.OF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovnp $0, $1;
} code {
    if ($flags.PF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovns $0, $1;
} code {
    if ($flags.SF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovnz $0, $1;
} code {
    if ($flags.ZF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovo $0, $1;
} code {
    if ($flags.OF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovp $0, $1;
} code {
    if ($flags.PF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovpe $0, $1;
} code {
    if ($flags.PF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovpo $0, $1;
} code {
    if ($flags.PF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovs $0, $1;
} code {
    if ($flags.SF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovz $0, $1;
} code {
    if ($flags.ZF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmp $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    $flags.ZF := v1.value == v2.value;
    $flags.SF := v1.svalue < v2.svalue;
    $flags.OF := unknown;
    $flags.CF := v1.uvalue < v2.uvalue;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

pattern {
    asm cmpsb;
} code {
    renew $cpu.esi as v1;
    v1.type := $type.ptr($type.x8);
    commit v1;
    renew $cpu.edi as v2;
    v2.type := $type.ptr($type.x8);
    commit v2;
    new v3;
    v3.addr := v1.pvalue;
    v3.bits := 8;
    commit v3;
    new v4;
    v4.addr := v2.pvalue;
    v3.bits := 8;
    commit v4;
    $flags.ZF := v3.value == v4.value;
    $flags.SF := v3.svalue < v4.svalue;
    $flags.OF := unknown;
    $flags.CF := v3.uvalue < v4.uvalue;
    $flags.AF := unknown;
    $flags.PF := unknown;
    if ($flags.DF == 0) {
        renew v1 as v5;
        v5.pvalue := v1.pvalue + 1;
        commit v5;
        renew v2 as v6;
        v6.pvalue := v2.pvalue + 1;
        commit v6;
    } else {
        renew v1 as v5;
        v5.pvalue := v1.pvalue - 1;
        commit v5;
        renew v2 as v6;
        v6.pvalue := v2.pvalue - 1;
        commit v6;
    }
    update $cpu.edi;
    update $cpu.esi;
}

pattern {
    asm cmpsw;
} code {
    renew $cpu.esi as v1;
    v1.type := $type.ptr($type.x16);
    commit v1;
    renew $cpu.edi as v2;
    v2.type := $type.ptr($type.x16);
    commit v2;
    new v3;
    v3.addr := v1.pvalue;
    v3.bits := 16;
    commit v3;
    new v4;
    v4.addr := v2.pvalue;
    v3.bits := 16;
    commit v4;
    $flags.ZF := v3.value == v4.value;
    $flags.SF := v3.svalue < v4.svalue;
    $flags.OF := unknown;
    $flags.CF := v3.uvalue < v4.uvalue;
    $flags.AF := unknown;
    $flags.PF := unknown;
    if ($flags.DF == 0) {
        renew v1 as v5;
        v5.pvalue := v1.pvalue + 2;
        commit v5;
        renew v2 as v6;
        v6.pvalue := v2.pvalue + 2;
        commit v6;
    } else {
        renew v1 as v5;
        v5.pvalue := v1.pvalue - 2;
        commit v5;
        renew v2 as v6;
        v6.pvalue := v2.pvalue - 2;
        commit v6;
    }
    update $cpu.edi;
    update $cpu.esi;
}

pattern {
    asm cmpsd;
} code {
    renew $cpu.esi as v1;
    v1.type := $type.ptr($type.x32);
    commit v1;
    renew $cpu.edi as v2;
    v2.type := $type.ptr($type.x32);
    commit v2;
    new v3;
    v3.addr := v1.pvalue;
    v3.bits := 32;
    commit v3;
    new v4;
    v4.addr := v2.pvalue;
    v3.bits := 32;
    commit v4;
    $flags.ZF := v3.value == v4.value;
    $flags.SF := v3.svalue < v4.svalue;
    $flags.OF := unknown;
    $flags.CF := v3.uvalue < v4.uvalue;
    $flags.AF := unknown;
    $flags.PF := unknown;
    if ($flags.DF == 0) {
        renew v1 as v5;
        v5.pvalue := v1.pvalue + 4;
        commit v5;
        renew v2 as v6;
        v6.pvalue := v2.pvalue + 4;
        commit v6;
    } else {
        renew v1 as v5;
        v5.pvalue := v1.pvalue - 4;
        commit v5;
        renew v2 as v6;
        v6.pvalue := v2.pvalue - 4;
        commit v6;
    }
    update $cpu.edi;
    update $cpu.esi;
}

pattern {
    asm repe_cmpsb;
} code {
    renew $cpu.esi as v1;
    v1.type := $type.ptr($type.x8);
    commit v1;
    renew $cpu.edi as v2;
    v2.type := $type.ptr($type.x8);
    commit v2;
    renew $cpu.ecx as v3;
    commit v3;
    for (;;) {
        join v8 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v6 to v1;
        join v7 to v2;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 8;
        commit v4;
        new v5;
        v5.addr := v2.pvalue;
        v5.bits := 8;
        commit v5;
        $flags.SF := v4.svalue < v5.svalue;
        $flags.CF := v4.uvalue < v5.uvalue;
        $flags.ZF := v4.value == v5.value;
        if ($flags.ZF == 0) {
            break;
        }
        if ($flags.DF == 0) {
            renew v2 as v6;
            v6.pvalue := v2.pvalue + 1;
            commit v6;
        } else {
            renew v2 as v6;
            v6.pvalue := v2.pvalue - 1;
            commit v6;
        }
        renew v3 as v7;
        v7.uvalue := v3.uvalue - 1;
        commit v7;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.OF := unknown;
}

pattern {
    asm repe_cmpsw;
} code {
    renew $cpu.esi as v1;
    v1.type := $type.ptr($type.x16);
    commit v1;
    renew $cpu.edi as v2;
    v2.type := $type.ptr($type.x16);
    commit v2;
    renew $cpu.ecx as v3;
    commit v3;
    for (;;) {
        join v8 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v6 to v1;
        join v7 to v2;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 16;
        commit v4;
        new v5;
        v5.addr := v2.pvalue;
        v5.bits := 16;
        commit v5;
        $flags.SF := v4.svalue < v5.svalue;
        $flags.CF := v4.uvalue < v5.uvalue;
        $flags.ZF := v4.value == v5.value;
        if ($flags.ZF == 0) {
            break;
        }
        if ($flags.DF == 0) {
            renew v2 as v6;
            v6.pvalue := v2.pvalue + 2;
            commit v6;
        } else {
            renew v2 as v6;
            v6.pvalue := v2.pvalue - 2;
            commit v6;
        }
        renew v3 as v7;
        v7.uvalue := v3.uvalue - 1;
        commit v7;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.OF := unknown;
}

pattern {
    asm repe_cmpsd;
} code {
    renew $cpu.esi as v1;
    v1.type := $type.ptr($type.x32);
    commit v1;
    renew $cpu.edi as v2;
    v2.type := $type.ptr($type.x32);
    commit v2;
    renew $cpu.ecx as v3;
    commit v3;
    for (;;) {
        join v8 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v6 to v1;
        join v7 to v2;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 32;
        commit v4;
        new v5;
        v5.addr := v2.pvalue;
        v5.bits := 32;
        commit v5;
        $flags.SF := v4.svalue < v5.svalue;
        $flags.CF := v4.uvalue < v5.uvalue;
        $flags.ZF := v4.value == v5.value;
        if ($flags.ZF == 0) {
            break;
        }
        if ($flags.DF == 0) {
            renew v2 as v6;
            v6.pvalue := v2.pvalue + 4;
            commit v6;
        } else {
            renew v2 as v6;
            v6.pvalue := v2.pvalue - 4;
            commit v6;
        }
        renew v3 as v7;
        v7.uvalue := v3.uvalue - 1;
        commit v7;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.OF := unknown;
}

alias asm repz_cmpsb := asm repe_cmpsb;
alias asm repz_cmpsw := asm repe_cmpsw;
alias asm repz_cmpsd := asm repe_cmpsd;

pattern {
    asm repne_cmpsb;
} code {
    renew $cpu.esi as v1;
    v1.type := $type.ptr($type.x8);
    commit v1;
    renew $cpu.edi as v2;
    v2.type := $type.ptr($type.x8);
    commit v2;
    renew $cpu.ecx as v3;
    commit v3;
    for (;;) {
        join v8 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v6 to v1;
        join v7 to v2;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 8;
        commit v4;
        new v5;
        v5.addr := v2.pvalue;
        v5.bits := 8;
        commit v5;
        $flags.SF := v4.svalue < v5.svalue;
        $flags.CF := v4.uvalue < v5.uvalue;
        $flags.ZF := v4.value == v5.value;
        if ($flags.ZF == 1) {
            break;
        }
        if ($flags.DF == 0) {
            renew v2 as v6;
            v6.pvalue := v2.pvalue + 1;
            commit v6;
        } else {
            renew v2 as v6;
            v6.pvalue := v2.pvalue - 1;
            commit v6;
        }
        renew v3 as v7;
        v7.uvalue := v3.uvalue - 1;
        commit v7;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.OF := unknown;
}

pattern {
    asm repne_cmpsw;
} code {
    renew $cpu.esi as v1;
    v1.type := $type.ptr($type.x16);
    commit v1;
    renew $cpu.edi as v2;
    v2.type := $type.ptr($type.x16);
    commit v2;
    renew $cpu.ecx as v3;
    commit v3;
    for (;;) {
        join v8 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v6 to v1;
        join v7 to v2;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 16;
        commit v4;
        new v5;
        v5.addr := v2.pvalue;
        v5.bits := 16;
        commit v5;
        $flags.SF := v4.svalue < v5.svalue;
        $flags.CF := v4.uvalue < v5.uvalue;
        $flags.ZF := v4.value == v5.value;
        if ($flags.ZF == 1) {
            break;
        }
        if ($flags.DF == 0) {
            renew v2 as v6;
            v6.pvalue := v2.pvalue + 2;
            commit v6;
        } else {
            renew v2 as v6;
            v6.pvalue := v2.pvalue - 2;
            commit v6;
        }
        renew v3 as v7;
        v7.uvalue := v3.uvalue - 1;
        commit v7;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.OF := unknown;
}

pattern {
    asm repne_cmpsd;
} code {
    renew $cpu.esi as v1;
    v1.type := $type.ptr($type.x32);
    commit v1;
    renew $cpu.edi as v2;
    v2.type := $type.ptr($type.x32);
    commit v2;
    renew $cpu.ecx as v3;
    commit v3;
    for (;;) {
        join v8 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v6 to v1;
        join v7 to v2;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 32;
        commit v4;
        new v5;
        v5.addr := v2.pvalue;
        v5.bits := 32;
        commit v5;
        $flags.SF := v4.svalue < v5.svalue;
        $flags.CF := v4.uvalue < v5.uvalue;
        $flags.ZF := v4.value == v5.value;
        if ($flags.ZF == 1) {
            break;
        }
        if ($flags.DF == 0) {
            renew v2 as v6;
            v6.pvalue := v2.pvalue + 4;
            commit v6;
        } else {
            renew v2 as v6;
            v6.pvalue := v2.pvalue - 4;
            commit v6;
        }
        renew v3 as v7;
        v7.uvalue := v3.uvalue - 1;
        commit v7;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.OF := unknown;
}

alias asm repnz_cmpsb := asm repne_cmpsb;
alias asm repnz_cmpsw := asm repne_cmpsw;
alias asm repnz_cmpsd := asm repne_cmpsd;

pattern {
    asm cmpxchg $0, $1;
} code {
    static if ($0.bits == 32) {
        renew $cpu.eax as v1;
        commit v1;
        renew $0 as v2;
        commit v2;
        $flags.SF := v1.svalue < v2.svalue;
        $flags.CF := v1.uvalue < v2.uvalue;
        $flags.PF := unknown;
        $flags.AF := unknown;
        if (v1.value == v2.value) {
            renew $1 as v3;
            commit v3;
            renew $0 as v4;
            v4.value := v3.value;
            commit v4;
            $flags.ZF := 1;
        } else {
            renew $0 as v5;
            commit v5;
            renew v1 as v6;
            v6.value := v5.value;
            commit v6;
            $flags.ZF := 0;
        }
    } else static if ($0.bits == 16) {
        renew $cpu.ax as v7;
        commit v7;
        renew $0 as v8;
        commit v8;
        $flags.SF := v7.svalue < v8.svalue;
        $flags.CF := v7.uvalue < v8.uvalue;
        $flags.PF := unknown;
        $flags.AF := unknown;
        if (v7.value == v8.value) {
            renew $1 as v9;
            commit v9;
            renew $0 as v10;
            v10.value := v9.value;
            commit v10;
            $flags.ZF := 1;
        } else {
            renew $0 as v11;
            commit v11;
            renew v7 as v12;
            v12.value := v11.value;
            commit v12;
            $flags.ZF := 0;
        }
    } else static if ($0.bits == 8) {
        renew $cpu.al as v13;
        commit v13;
        renew $0 as v14;
        commit v14;
        $flags.SF := v13.svalue < v14.svalue;
        $flags.CF := v13.uvalue < v14.uvalue;
        $flags.PF := unknown;
        $flags.AF := unknown;
        if (v13.value == v14.value) {
            renew $1 as v15;
            commit v15;
            renew $0 as v16;
            v16.value := v15.value;
            commit v16;
            $flags.ZF := 1;
        } else {
            renew $0 as v17;
            commit v17;
            renew v13 as v18;
            v18.value := v17.value;
            commit v18;
            $flags.ZF := 0;
        }
    } else {
        assert(0);
    }
}

// cmpxchg8b(void *$m64);
// cmpxchg16b(void *$m128);
// cpuid();
// crc32($dest, $src);

pattern {
    asm cwd;
} code {
    renew $cpu.ax as v1;
    commit v1;
    renew $cpu.dx_ax as v2;
    v2.svalue := v1.svalue;
    commit v2;
}

pattern {
    asm cdq;
} code {
    renew $cpu.eax as v1;
    commit v1;
    renew $cpu.edx_eax as v2;
    v2.svalue := v1.svalue;
    commit v2;
}

pattern {
    asm dec $0;
} code {
    renew $0 as v1;
    commit v1;
    renew v1 as v2;
    v2.value := v1.value - 1;
    commit v2;
    $flags.SF := v2.svalue < 0;
    $flags.ZF := v2.value == 0;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

pattern {
    asm div $0;
} code {
    renew $0 as v1;
    commit v1;
    static if ($0.bits == 32) {
        renew $cpu.edx_eax as v2;
        commit v2;
        renew $cpu.edx as v3;
        v3.uvalue := v2.uvalue % v1.uvalue;
        commit v3;
        renew $cpu.eax as v4;
        v4.uvalue := v2.uvalue / v1.uvalue;
        commit v4;
        update $cpu.edx, $cpu.eax;
    } else static if ($0.bits == 16) {
        renew $cpu.dx_ax as v5;
        commit v5;
        renew $cpu.dx as v6;
        v6.uvalue := v5.uvalue % v1.uvalue;
        commit v6;
        renew $cpu.ax as v7;
        v7.uvalue := v5.uvalue / v1.uvalue;
        commit v7;
        update $cpu.dx, $cpu.ax;
    } else static if ($0.bits == 8) {
        renew $cpu.ax as v8;
        commit v8;
        renew $cpu.ah as v9;
        v9.uvalue := v8.uvalue % v1.uvalue;
        commit v9;
        renew $cpu.al as v10;
        v10.uvalue := v8.uvalue / v1.uvalue;
        commit v10;
        update $cpu.al, $cpu.ah;
    } else {
        assert(0);
    }
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.SF := unknown;
    $flags.ZF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// asm enter $0, $1;

// asm hlt;

pattern {
    asm idiv $0;
} code {
    renew $0 as v1;
    commit v1;
    static if ($0.bits == 32) {
        renew $cpu.edx_eax as v2;
        commit v2;
        renew $cpu.edx as v3;
        v3.svalue := v2.svalue % v1.svalue;
        commit v3;
        renew $cpu.eax as v4;
        v4.svalue := v2.svalue / v1.svalue;
        commit v4;
        update $cpu.edx, $cpu.eax;
    } else static if ($0.bits == 16) {
        renew $cpu.dx_ax as v5;
        commit v5;
        renew $cpu.dx as v6;
        v6.svalue := v5.svalue % v1.svalue;
        commit v6;
        renew $cpu.ax as v7;
        v7.svalue := v5.svalue / v1.svalue;
        commit v7;
        update $cpu.dx, $cpu.ax;
    } else static if ($0.bits == 8) {
        renew $cpu.ax as v8;
        commit v8;
        renew $cpu.ah as v9;
        v9.svalue := v8.svalue % v1.svalue;
        commit v9;
        renew $cpu.al as v10;
        v10.svalue := v8.svalue / v1.svalue;
        commit v10;
        update $cpu.al, $cpu.ah;
    } else {
        assert(0);
    }
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.SF := unknown;
    $flags.ZF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

pattern {
    asm imul $0;
} code {
    renew $0 as v1;
    commit v1;
    static if ($0.bits == 32) {
        renew $cpu.eax as v2;
        commit v2;
        renew $cpu.eax_eax as v3;
        v3.svalue := v2.svalue * v1.svalue;
        commit v3;
    } else static if ($0.bits == 16) {
        renew $cpu.ax as v4;
        commit v4;
        renew $cpu.ax_ax as v5;
        v5.svalue := v4.svalue * v1.svalue;
        commit v5;
    } else {
        assert(0);
    }
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.SF := unknown;
    $flags.ZF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

pattern {
    asm imul $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.svalue := v1.svalue * v2.svalue;
    commit v3;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.SF := unknown;
    $flags.ZF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

pattern {
    asm imul $0, $1, $2;
} code {
    renew $1 as v1;
    commit v1;
    renew $2 as v2;
    commit v2;
    renew $0 as v3;
    v3.svalue := v1.svalue * v2.svalue;
    commit v3;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.SF := unknown;
    $flags.ZF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// asm in $dest, $src;

pattern {
    asm inc $0;
} code {
    renew $0 as v1;
    commit v1;
    renew v1 as v2;
    v2.value := v1.value + 1;
    commit v2;
    $flags.SF := v2.svalue < 0;
    $flags.ZF := v2.value == 0;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// insb();
// insw();
// insd();
// int3();
// int($a);
// into();
// invd();
// invlpg($m);
// invpcid($dest, $src);
// iret();
// iretd();

pattern {
    asm ja $0;
} code {
    if ($flags.ZF == 0 && $flags.CF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jae $0;
} code {
    if ($flags.CF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jb $0;
} code {
    if ($flags.CF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jbe $0;
} code {
    if ($flags.ZF == 1 || $flags.CF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jc $0;
} code {
    if ($flags.CF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jcxz $0;
} code {
    if ($cpu.cx.value == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jecxz $0;
} code {
    if ($cpu.ecx.value == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm je $0;
} code {
    if ($flags.ZF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jg $0;
} code {
    if ($flags.ZF == 0 && $flags.SFeqOF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jge $0;
} code {
    if ($flags.SFeqOF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jl $0;
} code {
    if ($flags.SFeqOF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jle $0;
} code {
    if ($flags.ZF == 1 && $flags.SFeqOF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jmp $0;
} code {
    goto $0.avalue;
}

pattern {
    asm jna $0;
} code {
    if ($flags.ZF == 1 || $flags.CF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jnae $0;
} code {
    if ($flags.CF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jnb $0;
} code {
    if ($flags.CF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jnb $0;
} code {
    if ($flags.ZF == 0 && $flags.CF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jnc $0;
} code {
    if ($flags.CF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jne $0;
} code {
    if ($flags.ZF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jng $0;
} code {
    if ($flags.ZF == 1 || $flags.SFeqOF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jnge $0;
} code {
    if ($flags.SFeqOF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jnl $0;
} code {
    if ($flags.SFeqOF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jnle $0;
} code {
    if ($flags.ZF == 0 && $flags.SFeqOF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jno $0;
} code {
    if ($flags.OF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jnp $0;
} code {
    if ($flags.PF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jns $0;
} code {
    if ($flags.SF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jnz $0;
} code {
    if ($flags.ZF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jo $0;
} code {
    if ($flags.OF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jp $0;
} code {
    if ($flags.PF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jpe $0;
} code {
    if ($flags.PF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jpo $0;
} code {
    if ($flags.PF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm js $0;
} code {
    if ($flags.SF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jz $0;
} code {
    if ($flags.ZF == 1) {
        goto $0.avalue;
    }
}

// lahf();
// lar($dest, $src);
// lds(void *$dest, void *$src);
// les(void *$dest, void *$src);
// lfs(void *$dest, void *$src);
// lgs(void *$dest, void *$src);

level(last) pattern {
    asm lea $0, $1;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.value := $1.addr;
    commit v1;
}

// lfence();
// lgdt($m1632);
// lidt($m1632);
// lldt($src);
// lmsw($src);
// lock();

pattern {
    asm lodsb;
} code {
    renew $cpu.esi as v1;
    v1.type := $type.ptr($type.x8);
    commit v1;
    renew $cpu.al as v2;
    v2.value := *v1.pvalue;
    commit v2;
    if ($flags.DF == 0) {
        renew v1 as v3;
        v3.pvalue := v1.pvalue + 1;
        commit v3;
    } else {
        renew v1 as v3;
        v3.pvalue := v1.pvalue - 1;
        commit v3;
    }
    update $cpu.al;
    update $cpu.esi;
}

pattern {
    asm lodsw;
} code {
    renew $cpu.esi as v1;
    v1.type := $type.ptr($type.x16);
    commit v1;
    renew $cpu.ax as v2;
    v2.value := *v1.pvalue;
    commit v2;
    if ($flags.DF == 0) {
        renew v1 as v3;
        v3.pvalue := v1.pvalue + 2;
        commit v3;
    } else {
        renew v1 as v3;
        v3.pvalue := v1.pvalue - 2;
        commit v3;
    }
    update $cpu.ax;
    update $cpu.esi;
}

pattern {
    asm lodsd;
} code {
    renew $cpu.esi as v1;
    v1.type := $type.ptr($type.x32);
    commit v1;
    renew $cpu.eax as v2;
    v2.value := *v1.pvalue;
    commit v2;
    if ($flags.DF == 0) {
        renew v1 as v3;
        v3.pvalue := v1.pvalue + 4;
        commit v3;
    } else {
        renew v1 as v3;
        v3.pvalue := v1.pvalue - 4;
        commit v3;
    }
    update $cpu.ax;
    update $cpu.esi;
}

pattern {
    asm rep_lodsb;
} code {
    renew $cpu.esi as v1;
    v1.type := $type.ptr($type.x8);
    commit v1;
    renew $cpu.rcx as v2;
    commit v2;
    for (;;) {
        join v5 to v2;
        if (v2.uvalue == 0) {
            break;
        }
        renew $cpu.al as v3;
        v3.value := *v1.pvalue;
        commit v3;
        join v4 to v1;
        if ($flags.DF == 0) {
            renew v1 as v4;
            v4.pvalue := v4.pvalue + 1;
            commit v4;
        } else {
            renew v1 as v4;
            v4.pvalue := v4.pvalue - 1;
            commit v4;
        }
        renew v2 as v5;
        v5.uvalue := v2.uvalue - 1;
        commit v5;
    }
    update $cpu.al;
    update $cpu.esi;
    renew v2 as v6;
    v6.value := 0;
    commit v6;
}

pattern {
    asm rep_lodsw;
} code {
    renew $cpu.esi as v1;
    v1.type := $type.ptr($type.x16);
    commit v1;
    renew $cpu.rcx as v2;
    commit v2;
    for (;;) {
        join v5 to v2;
        if (v2.uvalue == 0) {
            break;
        }
        renew $cpu.ax as v3;
        v3.value := *v1.pvalue;
        commit v3;
        join v4 to v1;
        if ($flags.DF == 0) {
            renew v1 as v4;
            v4.pvalue := v4.pvalue + 2;
            commit v4;
        } else {
            renew v1 as v4;
            v4.pvalue := v4.pvalue - 2;
            commit v4;
        }
        renew v2 as v5;
        v5.uvalue := v2.uvalue - 1;
        commit v5;
    }
    update $cpu.ax;
    update $cpu.esi;
    renew v2 as v6;
    v6.value := 0;
    commit v6;
}

pattern {
    asm rep_lodsd;
} code {
    renew $cpu.esi as v1;
    v1.type := $type.ptr($type.x32);
    commit v1;
    renew $cpu.rcx as v2;
    commit v2;
    for (;;) {
        join v5 to v2;
        if (v2.uvalue == 0) {
            break;
        }
        renew $cpu.eax as v3;
        v3.value := *v1.pvalue;
        commit v3;
        join v4 to v1;
        if ($flags.DF == 0) {
            renew v1 as v4;
            v4.pvalue := v4.pvalue + 4;
            commit v4;
        } else {
            renew v1 as v4;
            v4.pvalue := v4.pvalue - 4;
            commit v4;
        }
        renew v2 as v5;
        v5.uvalue := v2.uvalue - 1;
        commit v5;
    }
    update $cpu.eax;
    update $cpu.esi;
    renew v2 as v6;
    v6.value := 0;
    commit v6;
}

pattern {
    asm loop $0;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    if (v1.uvalue) {
        goto $0.avalue;
    }
    assert($cpu.cl.uvalue == 0);
    assert($cpu.ch.uvalue == 0);
    assert($cpu.cx.uvalue == 0);
    assert($cpu.ecx.uvalue == 0);
}

pattern {
    asm loope $0;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    if (v1.uvalue || $flags.ZF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm loopne $0;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    if (v1.uvalue || $flags.ZF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm loopnz $0;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    if (v1.uvalue || $flags.ZF == 0) {
        goto $0.avalue;
    }
}

pattern {
    loopz $0;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    if (v1.uvalue || $flags.ZF == 1) {
        goto $0.avalue;
    }
}

// lsl($dest, $src);
// ltr($src);
// mfence();
// monitor();

pattern {
    mov $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    renew $0 as v2;
    v2.value := v1.value;
    commit v2;
    assert(v1.value == v2.value);
}

pattern {
    asm movbe $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    new b0;
    b0.bits := 8;
    b0.uvalue := (v1.uvalue & 0xFF);
    commit b0;
    new b1;
    b1.bits := 8;
    b1.uvalue := ((v1.uvalue >> 8) & 0xFF);
    commit b1;
    static if ($0.bits == 16) {
        renew $0 as v16;
        v16.uvalue := (b1.uvalue | (b0.uvalue << 8));
        commit v16;
    } else static if ($0.bits == 32) {
        new b2;
        b2.bits := 8;
        b2.uvalue := ((v1.uvalue >> 16) & 0xFF);
        commit b2;
        new b3;
        b3.bits := 8;
        b3.uvalue := ((v1.uvalue >> 24) & 0xFF);
        commit b3;
        new w0;
        w0.bits := 16;
        w0.uvalue := ((b0.uvalue << 8) | b1.uvalue)
        commit w0;
        new w1;
        w1.bits := 16;
        w1.uvalue := ((b2.uvalue << 8) | b3.uvalue)
        commit w1;
        renew $0 as v32;
        v32.uvalue := ((w0.uvalue << 16) | w1.uvalue);
        commit v32;
    } else {
        assert(0);
    }
    update $0;
}

pattern {
    asm movsb;
} code {
    renew $cpu.esi as v1;
    v1.type := $type.ptr($type.x8);
    commit v1;
    renew $cpu.edi as v2;
    v2.type := $type.ptr($type.x8);
    commit v2;
    new v3;
    v3.addr := v1.pvalue
    v3.bits := 8;
    commit v3;
    new v4;
    v4.addr := v2.pvalue;
    v4.bits := 8;
    v4.value := v3.value;
    commit v4;
    if ($flags.DF == 0) {
        renew v1 as v5;
        v5.value := v1.value + 1;
        commit v5;
        renew v1 as v6;
        v6.value := v2.value + 1;
        commit v6;
    } else {
        renew v1 as v5;
        v5.value := v1.value - 1;
        commit v5;
        renew v1 as v6;
        v6.value := v2.value - 1;
        commit v6;
    }
    update $cpu.edi;
    update $cpu.esi;
}

pattern {
    asm movsw;
} code {
    renew $cpu.esi as v1;
    v1.type := $type.ptr($type.x16);
    commit v1;
    renew $cpu.edi as v2;
    v2.type := $type.ptr($type.x16);
    commit v2;
    new v3;
    v3.addr := v1.pvalue
    v3.bits := 16;
    commit v3;
    new v4;
    v4.addr := v2.pvalue;
    v4.bits := 16;
    v4.value := v3.value;
    commit v4;
    if ($flags.DF == 0) {
        renew v1 as v5;
        v5.value := v1.value + 2;
        commit v5;
        renew v1 as v6;
        v6.value := v2.value + 2;
        commit v6;
    } else {
        renew v1 as v5;
        v5.value := v1.value - 2;
        commit v5;
        renew v1 as v6;
        v6.value := v2.value - 2;
        commit v6;
    }
    update $cpu.edi;
    update $cpu.esi;
}

pattern {
    asm movsd;
} code {
    renew $cpu.esi as v1;
    v1.type := $type.ptr($type.x32);
    commit v1;
    renew $cpu.edi as v2;
    v2.type := $type.ptr($type.x32);
    commit v2;
    new v3;
    v3.addr := v1.pvalue
    v3.bits := 32;
    commit v3;
    new v4;
    v4.addr := v2.pvalue;
    v4.bits := 32;
    v4.value := v3.value;
    commit v4;
    if ($flags.DF == 0) {
        renew v1 as v5;
        v5.value := v1.value + 4;
        commit v5;
        renew v1 as v6;
        v6.value := v2.value + 4;
        commit v6;
    } else {
        renew v1 as v5;
        v5.value := v1.value - 4;
        commit v5;
        renew v1 as v6;
        v6.value := v2.value - 4;
        commit v6;
    }
    update $cpu.edi;
    update $cpu.esi;
}

pattern {
    asm rep_movsb;
} code {
    renew $cpu.edi as v1;
    commit v1;
    renew $cpu.edi as v2;
    commit v2;
    renew $cpu.ecx as v3;
    commit v3;
    if ($flags.DF == 0) {
        $fn.memcpy(v2.pvalue, v1.pvalue, v3.uvalue);
        renew v1 as v4;
        v4.pvalue := v1.pvalue + v3.uvalue;
        commit v4;
        renew v2 as v5;
        v5.pvalue := v2.pvalue + v3.uvalue;
        commit v5;
        continuous v1.pvalue, v1.pvalue + v3.uvalue;
        continuous v2.pvalue, v2.pvalue + v3.uvalue;
    } else if ($flags.DF == 1) {
        $fn.memcpy(v2.value - v3.uvalue, v1.value - v3.uvalue, v3.uvalue);
        renew v1 as v6;
        v6.pvalue := v1.pvalue - v3.uvalue;
        commit v6;
        renew v2 as v7;
        v7.pvalue := v2.pvalue - v3.uvalue;
        commit v7;
        continuous v1.pvalue - v3.uvalue, v1.pvalue;
        continuous v2.pvalue - v3.uvalue, v2.pvalue;
    } else {
        assert(0);
    }
    renew v3 as v8;
    v8.uvalue := 0;
    commit v8;
    update $cpu.edi;
    update $cpu.esi;
    update $cpu.ecx;
}

pattern {
    asm rep_movsw;
} code {
    renew $cpu.edi as v1;
    commit v1;
    renew $cpu.edi as v2;
    commit v2;
    renew $cpu.ecx as v3;
    commit v3;
    if ($flags.DF == 0) {
        $fn.wmemcpy(v2.pvalue, v1.pvalue, v3.uvalue / 2);
        renew v1 as v4;
        v4.pvalue := v1.pvalue + v3.uvalue;
        commit v4;
        renew v2 as v5;
        v5.pvalue := v2.pvalue + v3.uvalue;
        commit v5;
        continuous v1.pvalue, v1.pvalue + v3.uvalue;
        continuous v2.pvalue, v2.pvalue + v3.uvalue;
    } else if ($flags.DF == 1) {
        $fn.wmemcpy(v2.pvalue - v3.uvalue, v1.pvalue - v3.uvalue, v3.uvalue / 2);
        renew v1 as v6;
        v6.pvalue := v1.pvalue - v3.uvalue;
        commit v6;
        renew v2 as v7;
        v7.pvalue := v2.pvalue - v3.uvalue;
        commit v7;
        continuous v1.pvalue - v3.uvalue, v1.pvalue;
        continuous v2.pvalue - v3.uvalue, v2.pvalue;
    } else {
        assert(0);
    }
    renew v3 as v8;
    v8.uvalue := 0;
    commit v8;
    update $cpu.edi;
    update $cpu.esi;
    update $cpu.ecx;
}

pattern {
    asm rep_movsd;
} code {
    renew $cpu.esi as v1;
    commit v1;
    renew $cpu.edi as v2;
    commit v2;
    renew $cpu.ecx as v3;
    commit v3;
    for (;;) {
        join v6 to v3;
        if (!v3.value) {
            break;
        }
        new v4;
        v4.addr := v1.pvalue;
        commit v4;
        new v5;
        v5.addr := v2.pvalue;
        v5.value := v4.value;
        commit v5;
        join v6 to v1;
        join v7 to v2;
        if ($flags.DF == 0) {
            renew v1 as v6;
            v6.value := v1.value + 4;
            commit v6;
            renew v2 as v7;
            v7.value := v2.value + 4;
            commit v7;
        } else {
            renew v1 as v6;
            v6.value := v1.value - 4;
            commit v6;
            renew v2 as v7;
            v7.value := v2.value - 4;
            commit v7;
        }
        renew v3 as v8;
        v8.value := v3.value - 1;
        commit v8;
    }
    update $cpu.edi;
    update $cpu.esi;
    renew v3 as v9;
    v9.value := 0;
    commit v9;
    update $cpu.ecx;
}

pattern {
    movsx $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    renew $0 as v2;
    v2.svalue := v1.svalue;
    commit v2;
    assert(v1.svalue == v2.svalue);
}

pattern {
    asm movzx $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    renew $0 as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    assert(v1.uvalue == v2.uvalue);
}

pattern {
    asm mul $0;
} code {
    static if ($0.bits == 32) {
        renew $0 as v1;
        commit v1;
        renew $cpu.eax as v2;
        commit v2;
        renew $cpu.edx_eax as v3;
        v3.uvalue := v1.uvalue * v2.uvalue;
        commit v3;
    } else static if ($0.bits == 16) {
        renew $0 as v4;
        commit v4;
        renew $cpu.ax as v5;
        commit v5;
        renew $cpu.dx_ax as v6;
        v6.uvalue := v4.uvalue * v5.uvalue;
        commit v6;
    } else static if ($0.bits == 8) {
        renew $0 as v7;
        commit v7;
        renew $cpu.al as v8;
        commit v8;
        renew $cpu.ax as v9;
        v9.uvalue := v7.uvalue * v8.uvalue;
        commit v9;
    } else {
        assert(0);
    }
    $flags.OF := unknown;
    $flags.CF := unknown;
    $flags.SF := unknown;
    $flags.ZF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// mwait();

pattern {
    asm neg $0;
} code {
    renew $0 as v1;
    commit v1;
    renew v1 as v2;
    v2.svalue := -v1.svalue;
    commit v2;
    $flags.CF := v1.uvalue != 0;
    $flags.OF := unknown;
    $flags.SF := unknown;
    $flags.ZF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

pattern {
    asm nop;
} code {
}

pattern {
    asm nop $0;
} code {
}

pattern {
    asm not $0;
} code {
    renew $0 as v1;
    commit v1;
    renew v1 as v2;
    v2.uvalue := ~v1.uvalue;
    commit v2;
}

pattern {
    asm or $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    renew $0 as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | v2.uvalue);
    commit v3;
    $flags.SF := v3.svalue < 0;
    $flags.ZF := v3.value == 0;
    $flags.OF := 0;
    $flags.CF := 0;
    $flags.PF := unknown;
    $flags.AF := unknown;
}

// out($dest, $src);
// outsb();
// outsw();
// outsd();
// rep_outsb();
// rep_outsw();
// rep_outsd();
// pause();

pattern {
    pop $0;
} code {
    renew $cpu.esp as v1;
    commit v1;
    new v2;
    v2.addr := v1.pvalue;
    v2.bits := 32;
    commit v2;
    renew $0 as v3;
    v3.pvalue := v2.pvalue;
    commit v3;
    renew v1 as v4;
    v4.value := v1.value + 4;
    commit v4;
}

pattern {
    asm pop $0;
} code {
    pop $0;
}

pattern {
    asm popad;
} code {
    pop $cpu.edi;
    pop $cpu.esi;
    pop $cpu.ebp;
    pop $cpu.esp;
    pop $cpu.ebx;
    pop $cpu.edx;
    pop $cpu.ecx;
    pop $cpu.eax;
}

pattern {
    popcnt $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    new i1;
    i1.uvalue := 0;
    commit i1;
    new cnt1;
    cnt1.uvalue := 0;
    commit cnt1;
    for (;;) {
        if (v1.uvalue & (1 << i1.uvalue)) {
            renew cnt1 as cnt2;
            cnt2.uvalue := cnt1.uvalue + 1;
            commit cnt2;
        }
        renew i1 as i2;
        i2.uvalue := i1.uvalue + 1;
        commit i2;
        if (i2.uvalue >= $0.bits) {
            break;
        }
    }
    renew $0 as v2;
    v2.uvalue := cnt1.uvalue;
    commit v2;
}

// popf();
// popfd();
// prefetch0($m8);
// prefetch1($m8);
// prefetch2($m8);
// prefetchnta($m8);

pattern {
    asm pushad;
} code {
    new v1;
    v1.value := $cpu.esp;
    commit v1;
    push $cpu.eax;
    push $cpu.ecx;
    push $cpu.edx;
    push $cpu.ebx;
    push v1;
    push $cpu.ebp;
    push $cpu.esi;
    push $cpu.edi;
}

pattern {
    push $0;
} code {
    renew $0 as v1;
    commit v1;
    renew $cpu.esp as v2;
    commit v2;
    new v3;
    v3.addr := v2.pvalue;
    v3.bits := 32;
    v3.value := v1.value;
    commit v3;
    renew v2 as v4;
    v4.pvalue := v2.pvalue - 4;
    commit v4;
}

// pushf();
// pushfd();
// rcl(XSIGNED $dest, XSIGNED $src);
// rcr(XSIGNED $dest, XSIGNED $src);

pattern {
    asm rol $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    renew $0 as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := $fn._rotl(v2.uvalue, v1.uvalue);
    commit v3;
}

pattern {
    asm ror $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    renew $0 as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := $fn._rotr(v2.uvalue, v1.uvalue);
    commit v3;
}

// rdmsr();
// rdpmc();
// rdrand($dest);
// rdtsc();
// rdtscp();

// rsm();
// sahf();

pattern {
    asm sal $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    renew $0 as v2;
    commit v2;
    renew v2 as v3;
    v3.svalue := v2.svalue << v1.uvalue;
    commit v3;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.ZF := v3.svalue == 0;
    $flags.SF := v3.svalue < 0;
    $flags.PF := unknown;
    $flags.AF := unknown;
}

pattern {
    asm sar $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    renew $0 as v2;
    commit v2;
    renew v2 as v3;
    v3.svalue := v2.svalue >> v1.uvalue;
    commit v3;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.ZF := v3.svalue == 0;
    $flags.SF := v3.svalue < 0;
    $flags.PF := unknown;
    $flags.AF := unknown;
}

pattern {
    asm shl $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    renew $0 as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := v2.uvalue << v1.uvalue;
    commit v3;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.ZF := v3.uvalue == 0;
    $flags.SF := v3.svalue < 0;
    $flags.PF := unknown;
    $flags.AF := unknown;
}

pattern {
    asm shr $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    renew $0 as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := v2.uvalue >> v1.uvalue;
    commit v3;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.ZF := v3.uvalue == 0;
    $flags.SF := v3.svalue < 0;
    $flags.PF := unknown;
    $flags.AF := unknown;
}

pattern {
    sbb $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    renew $0 as v2;
    commit v2;
    renew v2 as v3;
    if ($flags.CF == 1) {
        v3.svalue := v2.svalue - v1.svalue - 1;
    } else {
        v3.svalue := v2.svalue - v1.svalue;
    }
    $flags.OF := v3.svalue > v1.svalue;
    $flags.ZF := v3.svalue == 0;
    $flags.SF := v3.svalue < 0;
    $flags.CF := v2.uvalue < v1.uvalue;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

pattern {
    asm scasb;
} code {
    renew $cpu.edi as v1;
    commit v1;
    renew $cpu.al as v2;
    commit v2;
    new v3;
    v3.addr := v1.pvalue;
    v3.bits := 8;
    commit v3;
    $flags.OF := v2.svalue < v3.svalue;
    $flags.ZF := v2.value == v3.value;
    $flags.SF := v2.svalue < v3.svalue;
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.CF := unknown;
    if ($flags.DF == 0) {
        renew v1 as v4;
        v4.pvalue := v1.pvalue + 1;
        commit v4;
    } else {
        renew v1 as v4;
        v4.pvalue := v1.pvalue - 1;
        commit v4;
    }
    update $cpu.edi;
}

pattern {
    asm scasw;
} code {
    renew $cpu.edi as v1;
    commit v1;
    renew $cpu.ax as v2;
    commit v2;
    new v3;
    v3.addr := v1.pvalue;
    v3.bits := 16;
    commit v3;
    $flags.OF := v2.svalue < v3.svalue;
    $flags.ZF := v2.value == v3.value;
    $flags.SF := v2.svalue < v3.svalue;
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.CF := unknown;
    if ($flags.DF == 0) {
        renew v1 as v4;
        v4.pvalue := v1.pvalue + 2;
        commit v4;
    } else {
        renew v1 as v4;
        v4.pvalue := v1.pvalue - 2;
        commit v4;
    }
    update $cpu.edi;
}

pattern {
    asm scasd;
} code {
    renew $cpu.edi as v1;
    commit v1;
    renew $cpu.eax as v2;
    commit v2;
    new v3;
    v3.addr := v1.pvalue;
    v3.bits := 32;
    commit v3;
    $flags.OF := v2.svalue < v3.svalue;
    $flags.ZF := v2.value == v3.value;
    $flags.SF := v2.svalue < v3.svalue;
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.CF := unknown;
    if ($flags.DF == 0) {
        renew v1 as v4;
        v4.pvalue := v1.pvalue + 4;
        commit v4;
    } else {
        renew v1 as v4;
        v4.pvalue := v1.pvalue - 4;
        commit v4;
    }
    update $cpu.edi;
}

pattern {
    asm repe_scasb;
} code {
    renew $cpu.edi as v1;
    commit v1;
    renew $cpu.al as v2;
    commit v2;
    renew $cpu.ecx as v3;
    commit v3;
    for (;;) {
        join v6 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v5 to v1;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 8;
        commit v4;
        $flags.OF := v2.svalue < v3.svalue;
        $flags.ZF := v2.value == v3.value;
        $flags.SF := v2.svalue < v3.svalue;
        if ($flags.ZF == 0) {
            break;
        }
        if ($flags.DF == 0) {
            renew v1 as v5;
            v5.pvalue := v1.pvalue + 1;
            commit v5;
        } else {
            renew v1 as v5;
            v5.pvalue := v1.pvalue - 1;
            commit v5;
        }
        renew v3 as v6;
        v6.uvalue := v3.uvalue - 1;
        commit v6;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.CF := unknown;
    update $cpu.edi;
    $cpu.ecx.value := unknown;
    update $cpu.ecx;
}

pattern {
    asm repe_scasw;
} code {
    renew $cpu.edi as v1;
    commit v1;
    renew $cpu.ax as v2;
    commit v2;
    renew $cpu.ecx as v3;
    commit v3;
    for (;;) {
        join v6 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v5 to v1;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 16;
        commit v4;
        $flags.OF := v2.svalue < v3.svalue;
        $flags.ZF := v2.value == v3.value;
        $flags.SF := v2.svalue < v3.svalue;
        if ($flags.ZF == 0) {
            break;
        }
        if ($flags.DF == 0) {
            renew v1 as v5;
            v5.pvalue := v1.pvalue + 2;
            commit v5;
        } else {
            renew v1 as v5;
            v5.pvalue := v1.pvalue - 2;
            commit v5;
        }
        renew v3 as v6;
        v6.uvalue := v3.uvalue - 1;
        commit v6;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.CF := unknown;
    update $cpu.edi;
    $cpu.ecx.value := unknown;
    update $cpu.ecx;
}

pattern {
    asm repe_scasd;
} code {
    renew $cpu.edi as v1;
    commit v1;
    renew $cpu.eax as v2;
    commit v2;
    renew $cpu.ecx as v3;
    commit v3;
    for (;;) {
        join v6 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v5 to v1;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 32;
        commit v4;
        $flags.OF := v2.svalue < v3.svalue;
        $flags.ZF := v2.value == v3.value;
        $flags.SF := v2.svalue < v3.svalue;
        if ($flags.ZF == 0) {
            break;
        }
        if ($flags.DF == 0) {
            renew v1 as v5;
            v5.pvalue := v1.pvalue + 4;
            commit v5;
        } else {
            renew v1 as v5;
            v5.pvalue := v1.pvalue - 4;
            commit v5;
        }
        renew v3 as v6;
        v6.uvalue := v3.uvalue - 1;
        commit v6;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.CF := unknown;
    update $cpu.edi;
    $cpu.ecx.value := unknown;
    update $cpu.ecx;
}

alias asm repz_scasb := asm repe_scasb;
alias asm repz_scasw := asm repe_scasw;
alias asm repz_scasd := asm repe_scasd;

pattern {
    asm repne_scasb;
} code {
    renew $cpu.edi as v1;
    commit v1;
    renew $cpu.al as v2;
    commit v2;
    renew $cpu.ecx as v3;
    commit v3;
    for (;;) {
        join v6 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v5 to v1;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 8;
        commit v4;
        $flags.OF := v2.svalue < v3.svalue;
        $flags.ZF := v2.value == v3.value;
        $flags.SF := v2.svalue < v3.svalue;
        if ($flags.ZF == 1) {
            break;
        }
        if ($flags.DF == 0) {
            renew v1 as v5;
            v5.pvalue := v1.pvalue + 1;
            commit v5;
        } else {
            renew v1 as v5;
            v5.pvalue := v1.pvalue - 1;
            commit v5;
        }
        renew v3 as v6;
        v6.uvalue := v3.uvalue - 1;
        commit v6;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.CF := unknown;
    update $cpu.edi;
    $cpu.ecx.value := unknown;
    update $cpu.ecx;
}

pattern {
    asm repne_scasw;
} code {
    renew $cpu.edi as v1;
    commit v1;
    renew $cpu.ax as v2;
    commit v2;
    renew $cpu.ecx as v3;
    commit v3;
    for (;;) {
        join v6 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v5 to v1;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 16;
        commit v4;
        $flags.OF := v2.svalue < v3.svalue;
        $flags.ZF := v2.value == v3.value;
        $flags.SF := v2.svalue < v3.svalue;
        if ($flags.ZF == 1) {
            break;
        }
        if ($flags.DF == 0) {
            renew v1 as v5;
            v5.pvalue := v1.pvalue + 2;
            commit v5;
        } else {
            renew v1 as v5;
            v5.pvalue := v1.pvalue - 2;
            commit v5;
        }
        renew v3 as v6;
        v6.uvalue := v3.uvalue - 1;
        commit v6;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.CF := unknown;
    update $cpu.edi;
    $cpu.ecx.value := unknown;
    update $cpu.ecx;
}

pattern {
    asm repne_scasd;
} code {
    renew $cpu.edi as v1;
    commit v1;
    renew $cpu.eax as v2;
    commit v2;
    renew $cpu.ecx as v3;
    commit v3;
    for (;;) {
        join v6 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v5 to v1;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 32;
        commit v4;
        $flags.OF := v2.svalue < v3.svalue;
        $flags.ZF := v2.value == v3.value;
        $flags.SF := v2.svalue < v3.svalue;
        if ($flags.ZF == 1) {
            break;
        }
        if ($flags.DF == 0) {
            renew v1 as v5;
            v5.pvalue := v1.pvalue + 4;
            commit v5;
        } else {
            renew v1 as v5;
            v5.pvalue := v1.pvalue - 4;
            commit v5;
        }
        renew v3 as v6;
        v6.uvalue := v3.uvalue - 1;
        commit v6;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.CF := unknown;
    update $cpu.edi;
    $cpu.ecx.value := unknown;
    update $cpu.ecx;
}

alias asm repnz_scasb := asm repne_scasb;
alias asm repnz_scasw := asm repne_scasw;
alias asm repnz_scasd := asm repne_scasd;

pattern {
    asm seta $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.ZF == 0 && $flags.CF == 0;
    commit v1;
}

pattern {
    asm setae $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.CF == 0;
    commit v1;
}

pattern {
    asm setb $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.CF;
    commit v1;
}

pattern {
    asm setbe $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.ZF || $flags.CF;
    commit v1;
}

pattern {
    asm setc $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.CF;
    commit v1;
}

pattern {
    asm sete $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.ZF;
    commit v1;
}

pattern {
    asm setg $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.ZF == 0 && $flags.SFeqOF;
    commit v1;
}

pattern {
    asm setge $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.SFeqOF;
    commit v1;
}

pattern {
    asm setl $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.SFeqOF;
    commit v1;
}

pattern {
    asm setle $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.ZF && $flags.SFeqOF;
    commit v1;
}

pattern {
    asm setna $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.ZF && $flags.CF;
    commit v1;
}

pattern {
    asm setnae $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.CF;
    commit v1;
}

pattern {
    asm setnb $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.CF == 0;
    commit v1;
}

pattern {
    asm setnbe $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.ZF == 0 && $flags.CF == 0;
    commit v1;
}

pattern {
    asm setnc $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.CF == 0;
    commit v1;
}

pattern {
    asm setne $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.ZF == 0;
    commit v1;
}

pattern {
    asm setng $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.ZF || $flags.SFeqOF;
    commit v1;
}

pattern {
    asm setnge $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.SFeqOF;
    commit v1;
}

pattern {
    asm setnl $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.SFeqOF;
    commit v1;
}

pattern {
    asm setnle $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.ZF == 0 && $flags.SFeqOF;
    commit v1;
}

pattern {
    asm setno $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.OF == 0;
    commit v1;
}

pattern {
    asm setnp $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.PF == 0;
    commit v1;
}

pattern {
    asm setns $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.SF == 0;
    commit v1;
}

pattern {
    asm setnz $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.ZF == 0;
    commit v1;
}

pattern {
    asm seto $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.OF;
    commit v1;
}

pattern {
    asm setp $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.PF;
    commit v1;
}

pattern {
    asm setpe $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.PF;
    commit v1;
}

pattern {
    asm setpo $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.PF == 0;
    commit v1;
}

pattern {
    asm sets $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.SF;
    commit v1;
}

pattern {
    asm setz $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.ZF;
    commit v1;
}

// sfence();
// sgdt();
// shld($dest, $src, $count);   // TODO:
// shrd($dest, $src, $count);   // TODO:
// sidt($m);
// sldt($rm16);
// smsw($rm);

pattern {
    stc;
} code {
    $flags.CF := 1;
}

pattern {
    std;
} code {
    $flags.DF := 1;
}

pattern {
    sti;
} code {
    $flags.IF := 1;
}

pattern {
    asm stosb;
} code {
    renew $cpu.edi as v1;
    commit v1;
    renew $cpu.al as v2;
    commit v2;
    new v3;
    v3.addr := v1.pvalue;
    v3.bits := 8;
    v3.value := v2.value;
    commit v3;
    if ($flags.DF == 0) {
        renew v1 as v4;
        v4.pvalue := v1.pvalue + 1;
        commit v4;
    } else {
        renew v1 as v4;
        v4.pvalue := v1.pvalue - 1;
        commit v4;
    }
    update $cpu.edi;
}

pattern {
    asm stosw;
} code {
    renew $cpu.edi as v1;
    commit v1;
    renew $cpu.ax as v2;
    commit v2;
    new v3;
    v3.addr := v1.pvalue;
    v3.bits := 16;
    v3.value := v2.value;
    commit v3;
    if ($flags.DF == 0) {
        renew v1 as v4;
        v4.pvalue := v1.pvalue + 2;
        commit v4;
    } else {
        renew v1 as v4;
        v4.pvalue := v1.pvalue - 2;
        commit v4;
    }
    update $cpu.edi;
}

pattern {
    asm stosd;
} code {
    renew $cpu.edi as v1;
    commit v1;
    renew $cpu.eax as v2;
    commit v2;
    new v3;
    v3.addr := v1.pvalue;
    v3.bits := 32;
    v3.value := v2.value;
    commit v3;
    if ($flags.DF == 0) {
        renew v1 as v4;
        v4.pvalue := v1.pvalue + 4;
        commit v4;
    } else {
        renew v1 as v4;
        v4.pvalue := v1.pvalue - 4;
        commit v4;
    }
    update $cpu.edi;
}

pattern {
    assert($flags.DF == 0);
    asm rep_stosb;
} code {
    renew $cpu.edi as v1;
    commit v1;
    renew $cpu.al as v2;
    commit v2;
    renew $cpu.ecx as v3;
    commit v3;
    $fn.memset(v1.pvalue, v2.value, v3.uvalue);
    renew v1 as v4;
    v4.pvalue := v1.pvalue + v3.uvalue;
    commit v4;
    update $cpu.edi;
    renew v3 as v5;
    v5.value := 0;
    commit v5;
    update $cpu.ecx;
}

pattern {
    assert($flags.DF == 1);
    asm rep_stosb;
} code {
    renew $cpu.edi as v1;
    commit v1;
    renew $cpu.al as v2;
    commit v2;
    renew $cpu.ecx as v3;
    commit v3;
    $fn.memset(v1.pvalue - v3.uvalue, v2.value, v3.uvalue);
    renew v1 as v4;
    v4.pvalue := v1.pvalue - v3.uvalue;
    commit v4;
    update $cpu.edi;
    renew v3 as v5;
    v5.value := 0;
    commit v5;
    update $cpu.ecx;
}

pattern {
    asm rep_stosw;
} code {
    renew $cpu.edi as v1;
    commit v1;
    renew $cpu.ax as v2;
    commit v2;
    renew $cpu.ecx as v3;
    commit v3;
    for (;;) {
        join v6 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 16;
        v4.value := v2.value;
        commit v4;
        join v5 to v1;
        if ($flags.DF == 0) {
            renew v1 as v5;
            v5.pvalue := v1.pvalue + 2;
            commit v5;
        } else {
            renew v1 as v5;
            v5.pvalue := v1.pvalue - 2;
            commit v5;
        }
        renew v3 as v6;
        v6.uvalue := v3.uvalue - 1;
        commit v6;
    }
    renew v3 as v7;
    v7.value := 0;
    commit v7;
    update $cpu.ecx;
}

pattern {
    asm rep_stosd;
} code {
    renew $cpu.edi as v1;
    commit v1;
    renew $cpu.eax as v2;
    commit v2;
    renew $cpu.ecx as v3;
    commit v3;
    for (;;) {
        join v6 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 32;
        v4.value := v2.value;
        commit v4;
        join v5 to v1;
        if ($flags.DF == 0) {
            renew v1 as v5;
            v5.pvalue := v1.pvalue + 4;
            commit v5;
        } else {
            renew v1 as v5;
            v5.pvalue := v1.pvalue - 4;
            commit v5;
        }
        renew v3 as v6;
        v6.uvalue := v3.uvalue - 1;
        commit v6;
    }
    renew v3 as v7;
    v7.value := 0;
    commit v7;
    update $cpu.ecx;
}

// str($rm16);

pattern {
    asm sub $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.value := v1.value - v2.value;
    commit v3;
    $flags.SF := v1.svalue < v2.svalue;
    $flags.CF := v1.uvalue < v2.uvalue;
    $flags.ZF := v1.value == 0;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

pattern {
    asm subnf $0, $1;   // CodeReverse extension
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.value := v1.value - v2.value;
    commit v3;
    update $0;
}

// sysenter();
// sysexit();

pattern {
    test $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    new v1 as v3;
    v3.value := (v1.value & v2.value);
    commit v3;
    $flags.ZF := v3.value == 0;
    $flags.SF := v3.svalue < 0;
    $flags.CF := 0;
    $flags.OF := 0;
    $flags.PF := unknown;
    $flags.AF := unknown;
}

// ud2();
// verr($rm16);
// verw($rm16);
// wait();
// fwait();
// wbinvd();
// wrmsr();

pattern {
    xadd $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.value := v1.value + v2.value;
    commit v3;
    renew v2 as v4;
    v4.value := v1.value;
    commit v4;
    $flags.CF := v3.uvalue < v1.uvalue;
    $flags.SF := v4.svalue < 0;
    $flags.ZF := v4.value == 0;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
    update $1;
}

pattern {
    asm xchg $0, $1;
} code {
    swap $0, $1;
}

// xgetbv();

pattern {
    asm xlat $0;
} code {
    asm xlatb;
}

pattern {
    asm xlatb;
} code {
    renew $cpu.al as v1;
    commit v1;
    renew $cpu.ebx as v2;
    commit v2;
    new v3;
    v3.addr := v2.pvalue + v1.uvalue;
    v3.bits := 8;
    commit v3;
    renew v1 as v4;
    v4.uvalue := v3.uvalue;
    commit v4;
    update $cpu.al;
}

pattern {
    asm xor $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.value := (v1.value ^ v2.value);
    $flags.SF := v3.svalue < 0;
    $flags.ZF := v3.value == 0;
    $flags.OF := 0;
    $flags.CF := 0;
    $flags.PF := unknown;
    $flags.AF := unknown;
    update $0;
}

// xrstor($mem);
// xsave($mem);
// xsaveopt($mem);
// xsetbv();
