////////////////////////////////////////////////////////////////////////////
// arch_x64.dat
// Copyright (C) 2015 Katayama Hirofumi MZ.  All rights reserved.
////////////////////////////////////////////////////////////////////////////
// This file is part of CodeReverse.
// This file might be incomplete and/or incorrect.
////////////////////////////////////////////////////////////////////////////
// [Attributes]
// .addr:   address
// .type:   type
// .bits:   size in bits
//
// [Types]
// $type.s8:    signed 8-bit type
// $type.u8:    unsigned 8-bit type
// $type.x8:    signed/unsigned 8-bit type
// $type.s16:   signed 16-bit type
// $type.u16:   unsigned 16-bit type
// $type.x16:   signed/unsigned 16-bit type
// $type.s32:   signed 32-bit type
// $type.u32:   unsigned 32-bit type
// $type.x32:   signed/unsigned 32-bit type
// $type.s64:   signed 64-bit type
// $type.u64:   unsigned 64-bit type
// $type.x64:   signed/unsigned 64-bit type
// $type.ptr(ty):   make a pointer type to the type ty
// $type.ref(ty):   make a base type of the pointer type ty
//
// [Values]
// .value:  value
// .svalue: signed value
// .uvalue: unsigned value
// .pvalue: pointer value
// .avalue: label value
//
// [Functions]
// $fn.fname:   a call of the function named fname
//
// [Parameters]
// $0, $1, $2, ...:         parameters
// $0N, $1N, $2N, ...:      numeric parameters
// $0R, $1R, $2R, ...:      register parameters
// $0M, $1M, $2M, ...:      memory parameters
////////////////////////////////////////////////////////////////////////////

define $cpu := {
    {"rdx_rax", 128},
    {"edx_eax", 64},
    {"dx_ax", 32},
    {"rax", 64},
    {"eax", 32},
    {"ax", 16},
    {"al", 8},
    {"ah", 8},
    {"rdx", 64},
    {"edx", 32},
    {"dx", 16},
    {"dl", 8},
    {"dh", 8},
    {"rbx", 64},
    {"ebx", 32},
    {"bx", 16},
    {"bl", 8},
    {"bh", 8},
    {"rcx", 64},
    {"ecx", 32},
    {"cx", 16},
    {"cl", 8},
    {"ch", 8},
    {"rdi", 64},
    {"edi", 32},
    {"di", 16},
    {"dil", 8},
    {"rsi", 64},
    {"esi", 32},
    {"si", 16},
    {"sil", 8},
    {"rbp", 64},
    {"ebp", 32},
    {"bp", 16},
    {"bpl", 8},
    {"rsp", 64},
    {"esp", 32},
    {"sp", 16},
    {"spl", 8},
    {"r8", 64},
    {"r8d", 32},
    {"r8w", 16},
    {"r8l", 8},
    {"r9", 64},
    {"r9d", 32},
    {"r9w", 16},
    {"r9l", 8},
    {"r10", 64},
    {"r10d", 32},
    {"r10w", 16},
    {"r10l", 8},
    {"r11", 64},
    {"r11d", 32},
    {"r11w", 16},
    {"r11l", 8},
    {"r12", 64},
    {"r12d", 32},
    {"r12w", 16},
    {"r12l", 8},
    {"r13", 64},
    {"r13d", 32},
    {"r13w", 16},
    {"r13l", 8},
    {"r14", 64},
    {"r14d", 32},
    {"r14w", 16},
    {"r14l", 8},
    {"r15", 64},
    {"r15d", 32},
    {"r15w", 16},
    {"r15l", 8},
    {"rip", 64},
    {"eip", 32},
    {"ip", 16},
    {"rflags", 64},
    {"eflags", 32},
    {"flags", 16},
    {"cs", 16},
    {"ds", 16},
    {"ss", 16},
    {"es", 16},
    {"fs", 16},
    {"gs", 16},
};

define $flags := {
    {"OF", 1},
    {"DF", 1},
    {"IF", 1},
    {"TF", 1},
    {"SF", 1},
    {"ZF", 1},
    {"AF", 1},
    {"PF", 1},
    {"CF", 1},
};

define $fpu := {
    {"st0", 80},
    {"st1", 80},
    {"st2", 80},
    {"st3", 80},
    {"st4", 80},
    {"st5", 80},
    {"st6", 80},
    {"st7", 80},
    {"control", 16},
    {"status", 16},
    {"tag", 16},
    {"instruction", 64},
    {"operand", 64},
};

define $sse := {
    {"mm0", 64},
    {"mm1", 64},
    {"mm2", 64},
    {"mm3", 64},
    {"mm4", 64},
    {"mm5", 64},
    {"mm6", 64},
    {"mm7", 64},
    {"xmm0", 128},
    {"xmm1", 128},
    {"xmm2", 128},
    {"xmm3", 128},
    {"xmm4", 128},
    {"xmm5", 128},
    {"xmm6", 128},
    {"xmm7", 128},
    {"mxcsr", 32},
};

////////////////////////////////////////////////////////////////////////////
// level 0

level(0) pattern {
    asm nop;
} code {
}

level(0) pattern {
    asm nop $0;
} code {
}

level(0) pattern {
    asm push $0;
    asm pop $0;
} code {
}

level(0) pattern {
    asm push $0;
    asm push $1;
    asm pop $1;
    asm pop $0;
} code {
}

level(0) pattern {
    asm push $0;
    asm push $1;
    asm push $2;
    asm pop $2;
    asm pop $1;
    asm pop $0;
} code {
}

level(0) pattern {
    asm push $0;
    asm push $1;
    asm push $2;
    asm push $3;
    asm pop $3;
    asm pop $2;
    asm pop $1;
    asm pop $0;
} code {
}

level(0) pattern {
    asm push $0;
    asm pop $1;
} code {
    asm mov $1, $0;
}

level(0) pattern {
    asm push $0;
    asm push $1;
    asm pop $2;
    asm pop $3;
} code {
    asm mov $2, $1;
    asm mov $3, $0;
}

level(0) pattern {
    asm push $0;
    asm push $1;
    asm push $2;
    asm pop $3;
    asm pop $4;
    asm pop $5;
} code {
    asm mov $3, $2;
    asm mov $4, $1;
    asm mov $5, $0;
}

level(0) pattern {
    asm push $0;
    asm push $1;
    asm push $2;
    asm push $3;
    asm pop $4;
    asm pop $5;
    asm pop $6;
    asm pop $7;
} code {
    asm mov $4, $3;
    asm mov $5, $2;
    asm mov $6, $1;
    asm mov $7, $0;
}

level(0) pattern {
    asm push $0;
    asm push $1;
    asm push $2;
    asm push $3;
    asm push $4;
    asm pop $5;
    asm pop $6;
    asm pop $7;
    asm pop $8;
    asm pop $9;
} code {
    asm mov $5, $4;
    asm mov $6, $3;
    asm mov $7, $2;
    asm mov $8, $1;
    asm mov $9, $0;
}

level(0) pattern {
    asm push $0;
    asm push $1;
    asm push $2;
    asm push $3;
    asm push $4;
    asm push $5;
    asm pop $6;
    asm pop $7;
    asm pop $8;
    asm pop $9;
    asm pop $10;
    asm pop $11;
} code {
    asm mov $6, $5;
    asm mov $7, $4;
    asm mov $8, $3;
    asm mov $9, $2;
    asm mov $10, $1;
    asm mov $11, $0;
}

level(0) pattern {
    asm cdq;
    asm xor eax, edx;
    asm sub eax, edx;
} code {
    renew $cpu.eax as v1;
    commit v1;
    renew v1 as v2;
    v2.svalue := $fn.abs(v1.svalue);
    commit v2;
    renew $cpu.edx as v3;
    v3.value := unknown;
    commit v3;
    update $cpu.eax;
    update $cpu.edx;
}

level(0) pattern {
    asm cqo;
    asm xor rax, rdx;
    asm sub rax, rdx;
} code {
    renew $cpu.rax as v1;
    commit v1;
    renew v1 as v2;
    v2.svalue := $fn._abs64(v1.svalue);
    commit v2;
    renew $cpu.rdx as v3;
    v3.value := unknown;
    commit v3;
    update $cpu.rax;
    update $cpu.rdx;
}

level(0) pattern {
    asm push rbp;
    asm mov rbp, rsp;
    asm sub rsp, $0;
} code {
    enter $0, 0;
}

level(0) pattern {
    asm push rbp;
    asm mov rbp, rsp;
} code {
    enter 0, 0;
}

level(0) pattern {
    asm mov rsp, rbp;
    asm pop rbp;
} code {
    leave;
}

level(0) pattern {
    asm enter $0, $1;
} code {
    enter $0, $1;
}

level(0) pattern {
    asm leave;
} code {
    leave;
}

level(0) pattern {
    asm xor $0, $0;
    asm not $0;
} code {
    static if ($0.bits == 64) {
        renew $0 as v1;
        v1.svalue := -1, v1.uvalue := 0xFFFFFFFFFFFFFFFF;
        commit v1;
        assert(v1.uvalue == 0xFFFFFFFFFFFFFFFF);
        assert(v1.svalue == -1);
    } else static if ($0.bits == 32) {
        renew $0 as v2;
        v2.svalue := -1, v2.uvalue := 0xFFFFFFFF;
        commit v2;
        assert(v2.uvalue == 0xFFFFFFFF);
        assert(v2.svalue == -1);
    } else static if ($0.bits == 16) {
        renew $0 as v3;
        v3.svalue := -1, v3.uvalue := 0xFFFF;
        commit v3;
        assert(v3.uvalue == 0xFFFF);
        assert(v3.svalue == -1);
    } else static if ($0.bits == 8) {
        renew $0 as v4;
        v4.svalue := -1, v4.uvalue := 0xFF;
        commit v4;
        assert(v4.uvalue == 0xFF);
        assert(v4.svalue == -1);
    } else {
        assert(0);
    }
    update $0;
}

level(0) pattern {
    asm xor $0, $0;
    asm inc $0;
} code {
    renew $0 as v1;
    v1.value := 1;
    commit v1;
    $flags.OF := 0;
    $flags.SF := 0;
    $flags.ZF := 0;
    $flags.AF := unknown;
    $flags.PF := unknown;
    assert(v1.uvalue == 1);
    assert(v1.svalue == 1);
    update $0;
}

level(0) pattern {
    asm xor $0, $0;
    asm dec $0;
} code {
    static if ($0.bits == 64) {
        renew $0 as v1;
        v1.uvalue := 0xFFFFFFFFFFFFFFFF, v1.svalue := -1;
        commit v1;
        assert(v1.uvalue == 0xFFFFFFFFFFFFFFFF);
        assert(v1.svalue == -1);
    } else static if ($0.bits == 32) {
        renew $0 as v2;
        v2.uvalue := 0xFFFFFFFF, v2.svalue := -1;
        commit v2;
        assert(v2.uvalue == 0xFFFFFFFF);
        assert(v2.svalue == -1);
    } else static if ($0.bits == 16) {
        renew $0 as v3;
        v3.uvalue := 0xFFFF, v3.svalue := -1;
        commit v3;
        assert(v3.uvalue == 0xFFFF);
        assert(v3.svalue == -1);
    } else static if ($0.bits == 8) {
        renew $0 as v4;
        v4.uvalue := 0xFF, v4.svalue := -1;
        commit v4;
        assert(v4.uvalue == 0xFF);
        assert(v4.svalue == -1);
    } else {
        assert(0);
    }
    $flags.OF := 0;
    $flags.SF := 1;
    $flags.ZF := 0;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

level(0) pattern {
    asm mov $0, $0;
} code {
}

level(0) pattern {
    asm movnti $0, $0;
} code {
}

level(0) pattern {
    asm movnti $0, $1;
} code {
    asm mov $0, $1;
}

level(0) pattern {
    asm lea $0R, [$0R];
} code {
}

level(0) pattern {
    asm lea $0R, [$0R+$1N];
} code {
    asm addnf $0R, $1N;       // CodeReverse extension
}

level(0) pattern {
    asm lea $0R, [$0R-$1N];
} code {
    asm subnf $0R, $1N;       // CodeReverse extension
}

level(0) pattern {
    asm shl $0, 1;
    asm shl $0, 1;
    asm shl $0, 1;
    asm shl $0, 1;
    asm shl $0, 1;
} code {
    asm shl $0, 5;
}

level(0) pattern {
    asm shl $0, 1;
    asm shl $0, 1;
    asm shl $0, 1;
    asm shl $0, 1;
} code {
    asm shl $0, 4;
}

level(0) pattern {
    asm shl $0, 1;
    asm shl $0, 1;
    asm shl $0, 1;
} code {
    asm shl $0, 3;
}

level(0) pattern {
    asm shl $0, 1;
    asm shl $0, 1;
} code {
    asm shl $0, 2;
}

level(0) pattern {
    asm shr $0, 1;
    asm shr $0, 1;
    asm shr $0, 1;
    asm shr $0, 1;
    asm shr $0, 1;
} code {
    asm shr $0, 5;
}

level(0) pattern {
    asm shr $0, 1;
    asm shr $0, 1;
    asm shr $0, 1;
    asm shr $0, 1;
} code {
    asm shr $0, 4;
}

level(0) pattern {
    asm shr $0, 1;
    asm shr $0, 1;
    asm shr $0, 1;
} code {
    asm shr $0, 3;
}

level(0) pattern {
    asm shr $0, 1;
    asm shr $0, 1;
} code {
    asm shr $0, 2;
}

level(0) pattern {
    asm sal $0, 1;
    asm sal $0, 1;
    asm sal $0, 1;
    asm sal $0, 1;
    asm sal $0, 1;
} code {
    asm sal $0, 5;
}

level(0) pattern {
    asm sal $0, 1;
    asm sal $0, 1;
    asm sal $0, 1;
    asm sal $0, 1;
} code {
    asm sal $0, 4;
}

level(0) pattern {
    asm sal $0, 1;
    asm sal $0, 1;
    asm sal $0, 1;
} code {
    asm sal $0, 3;
}

level(0) pattern {
    asm sal $0, 1;
    asm sal $0, 1;
} code {
    asm sal $0, 2;
}

level(0) pattern {
    asm sar $0, 1;
    asm sar $0, 1;
    asm sar $0, 1;
    asm sar $0, 1;
    asm sar $0, 1;
} code {
    asm sar $0, 5;
}

level(0) pattern {
    asm sar $0, 1;
    asm sar $0, 1;
    asm sar $0, 1;
    asm sar $0, 1;
} code {
    asm sar $0, 4;
}

level(0) pattern {
    asm sar $0, 1;
    asm sar $0, 1;
    asm sar $0, 1;
} code {
    asm sar $0, 3;
}

level(0) pattern {
    asm sar $0, 1;
    asm sar $0, 1;
} code {
    asm sar $0, 2;
}

level(0) pattern {
    asm jmp $label.1;
$label.1:
} code {
$label.1:
}

////////////////////////////////////////////////////////////////////////////
// level 1

// strlen #0
level(1) pattern {
    asm repne_scasb;
    asm not rcx;
    asm lea $0, [rcx-1];
} code {
    if ($cpu.al.value == 0 && 
        ($cpu.rcx.svalue == -1 || $cpu.rcx.uvalue == 0xFFFFFFFFFFFFFFFF))
    {
        renew $cpu.rdi as v1;
        v1.type := $type.ptr($type.s8);
        commit v1;
        renew $0 as v2;
        v2.uvalue := $fn.strlen(v1.pvalue);
        commit v2;
        renew v1 as v3;
        v3.pvalue := v1.pvalue + v2.value;
        commit v3;
        renew $cpu.rcx as v4;
        v4.value := unknown;
        commit v4;
    } else {
        asm repne_scasb;
        renew $cpu.rcx as v5;
        commit v5;
        renew v5 as v6;
        v6.uvalue := ~v5.uvalue;
        commit v6;
        renew $cpu.rcx as v7;
        commit v7;
        renew $0 as v8;
        v8.value := v7.value - 1;
        commit v8;
    }
    update $cpu.rcx;
    update $0;
}

// wcslen #0
level(1) pattern {
    asm lea $0, [rax+0x2];
$label.1:
    asm mov cx, [eax];
    asm addnf rax, 2;
    asm test cx, cx;
    asm jnz $label.1;
    asm sub rax, $0;
    asm sar rax, 1;
} code {
    renew $cpu.rax as v1;
    commit v1;
    renew v1 as v2;
    v2.uvalue := $fn.wcslen(v1.pvalue);
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    assert($cpu.cl.value == 0);
    assert($cpu.ch.value == 0);
    assert($cpu.cx.value == 0);
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcslen #1
level(1) pattern {
    asm lea $0, [rax+0x2];
$label.1:
    asm mov cx, [eax];
    asm addnf rax, 2;
    asm test cx, cx;
    asm jnz $label.1;
    asm sub rax, $0;
    asm shr rax, 1;
} code {
    renew $cpu.rax as v1;
    commit v1;
    renew v1 as v2;
    v2.uvalue := $fn.wcslen(v1.pvalue);
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcslen #2
level(1) pattern {
    asm lea $0, [rax+0x2];
$label.1:
    asm mov cx, [eax];
    asm add rax, 2;
    asm test cx, cx;
    asm jnz $label.1;
    asm sub rax, $0;
    asm sar rax, 1;
} code {
    renew $cpu.rax as v1;
    commit v1;
    renew v1 as v2;
    v2.uvalue := $fn.wcslen(v1.pvalue);
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcslen #3
level(1) pattern {
    asm lea $0, [rax+0x2];
$label.1:
    asm mov cx, [eax];
    asm add rax, 2;
    asm test cx, cx;
    asm jnz $label.1;
    asm sub rax, $0;
    asm shr rax, 1;
} code {
    renew $cpu.rax as v1;
    commit v1;
    renew v1 as v2;
    v2.uvalue := $fn.wcslen(v1.pvalue);
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcslen #4
level(1) pattern {
    asm lea $0, [rax+0x2];
$label.1:
    asm mov cx, [eax];
    asm inc rax;
    asm inc rax;
    asm test cx, cx;
    asm jnz $label.1;
    asm sub rax, $0;
    asm sar rax, 1;
} code {
    renew $cpu.rax as v1;
    commit v1;
    renew v1 as v2;
    v2.uvalue := $fn.wcslen(v1.pvalue);
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcslen #5
level(1) pattern {
    asm lea $0, [rax+0x2];
$label.1:
    asm mov cx, [eax];
    asm inc rax;
    asm inc rax;
    asm test cx, cx;
    asm jnz $label.1;
    asm sub rax, $0;
    asm shr rax, 1;
} code {
    renew $cpu.rax as v1;
    commit v1;
    renew v1 as v2;
    v2.uvalue := $fn.wcslen(v1.pvalue);
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcslen * 2 #0
level(1) pattern {
    asm lea $0, [rax+0x2];
$label.1:
    asm mov cx, [eax];
    asm addnf rax, 2;
    asm test cx, cx;
    asm jnz $label.1;
    asm sub rax, $0;
} code {
    renew $cpu.rax as v1;
    commit v1;
    renew v1 as v2;
    v2.uvalue := $fn.wcslen(v1.pvalue) * 2;
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcslen * 2 #1
level(1) pattern {
    asm lea $0, [rax+0x2];
$label.1:
    asm mov cx, [eax];
    asm add rax, 2;
    asm test cx, cx;
    asm jnz $label.1;
    asm sub rax, $0;
} code {
    renew $cpu.rax as v1;
    commit v1;
    renew v1 as v2;
    v2.uvalue := $fn.wcslen(v1.pvalue) * 2;
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcslen * 2 #2
level(1) pattern {
    asm lea $0, [rax+0x2];
$label.1:
    asm mov cx, [eax];
    asm inc rax;
    asm inc rax;
    asm test cx, cx;
    asm jnz $label.1;
    asm sub rax, $0;
} code {
    renew $cpu.rax as v1;
    commit v1;
    renew v1 as v2;
    v2.uvalue := $fn.wcslen(v1.pvalue) * 2;
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcslen * 2 #3
level(1) pattern {
    asm lea $0, [rax+0x2];
$label.1:
    asm mov cx, [eax];
    asm inc rax;
    asm inc rax;
    asm test cx, cx;
    asm jnz $label.1;
    asm sub rax, $0;
} code {
    renew $cpu.rax as v1;
    commit v1;
    renew v1 as v2;
    v2.uvalue := $fn.wcslen(v1.pvalue) * 2;
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// ptr + wcslen * 2 #0
level(1) pattern {
    asm lea $0, [rax+0x2];
$label.1:
    asm mov cx, [eax];
    asm addnf rax, 2;
    asm test cx, cx;
    asm jnz $label.1;
} code {
    renew $cpu.rax as v1;
    commit v1;
    renew v1 as v2;
    v2.pvalue := v1.pvalue + $fn.wcslen(v1.pvalue) * 2;
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// ptr + wcslen * 2 #1
level(1) pattern {
    asm lea $0, [rax+0x2];
$label.1:
    asm mov cx, [eax];
    asm add rax, 2;
    asm test cx, cx;
    asm jnz $label.1;
} code {
    renew $cpu.rax as v1;
    commit v1;
    renew v1 as v2;
    v2.pvalue := v1.pvalue + $fn.wcslen(v1.pvalue) * 2;
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// ptr + wcslen * 2 #2
level(1) pattern {
    asm lea $0, [rax+0x2];
$label.1:
    asm mov cx, [eax];
    asm inc rax;
    asm inc rax;
    asm test cx, cx;
    asm jnz $label.1;
} code {
    renew $cpu.rax as v1;
    commit v1;
    renew v1 as v2;
    v2.pvalue := v1.pvalue + $fn.wcslen(v1.pvalue) * 2;
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// ptr + wcslen * 2 #3
level(1) pattern {
    asm lea $0, [rax+0x2];
$label.1:
    asm mov cx, [eax];
    asm inc rax;
    asm inc rax;
    asm test cx, cx;
    asm jnz $label.1;
} code {
    renew $cpu.rax as v1;
    commit v1;
    renew v1 as v2;
    v2.pvalue := v1.pvalue + $fn.wcslen(v1.pvalue) * 2;
    commit v2;
    renew $cpu.cx as v3;
    v3.value := 0;
    commit v3;
    update $cpu.cx;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcscpy #0
level(1) pattern {
    asm sub $0, rax;
$label.1:
    asm movzx rcx, [rax];
    asm addnf rax, 2;
    asm mov [$0+rax-0x2], cx;
    asm test cx, cx;
    asm jnz $label.1;
} code {
    renew $cpu.rax as v1;
    commit v1;
    renew $0 as v2;
    commit v2;
    $fn.wcscpy(v2.pvalue, v1.pvalue);
    renew $cpu.cx as v3;
    v3.uvalue := 0;
    commit v3;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcscpy #1
level(1) pattern {
    asm sub $0, rax;
$label.1:
    asm movzx rcx, [rax];
    asm add rax, 0x2;
    asm mov [$0+rax-0x2], cx;
    asm test cx, cx;
    asm jnz $label.1;
} code {
    renew $cpu.rax as v1;
    commit v1;
    renew $0 as v2;
    commit v2;
    $fn.wcscpy(v2.pvalue, v1.pvalue);
    renew $cpu.cx as v3;
    v3.uvalue := 0;
    commit v3;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcscpy #2
level(1) pattern {
    asm sub $0, rax;
$label.1:
    asm movzx rcx, [rax];
    asm inc rax;
    asm inc rax;
    asm mov [$0+rax-0x2], cx;
    asm test cx, cx;
    asm jnz $label.1;
} code {
    renew $cpu.rax as v1;
    commit v1;
    renew $0 as v2;
    commit v2;
    $fn.wcscpy(v2.pvalue, v1.pvalue);
    renew $cpu.cx as v3;
    v3.uvalue := 0;
    commit v3;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// wcscpy #3
level(1) pattern {
    asm sub $0, rax;
$label.1:
    asm movzx rcx, [rax];
    asm inc rax;
    asm inc rax;
    asm mov [$0+rax-0x2], cx;
    asm test cx, cx;
    asm jnz $label.1;
} code {
    renew $cpu.rax as v1;
    commit v1;
    renew $0 as v2;
    commit v2;
    $fn.wcscpy(v2.pvalue, v1.pvalue);
    renew $cpu.cx as v3;
    v3.uvalue := 0;
    commit v3;
    renew $0 as v4;
    v4.value := unknown;
    commit v4;
    update $0;
    $flags.ZF := unknown;
    $flags.SF := unknown;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

////////////////////////////////////////////////////////////////////////////
// level 2

level(2) pattern {
    asm xor $0, $0;
} code {
    renew $0 as v1;
    v1.value := 0;
    commit v1;
    $flags.SF := 0;
    $flags.ZF := 1;
    $flags.OF := 0;
    $flags.CF := 0;
    $flags.PF := unknown;
    $flags.AF := unknown;
    assert(v1.value == 0);
    update $0;
}

level(2) pattern {
    asm add $0, $0;
} code {
    renew $0 as v1;
    commit v1;
    renew v1 as v2;
    v2.value := v1.value * 2;
    commit v2;
    $flags.ZF := v2.value == 0;
    $flags.SF := v2.svalue < 0;
    $flags.CF := v2.uvalue < v1.uvalue;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

level(2) pattern {
    asm and $0, $0;
} code {
    renew $0 as v1;
    commit v1;
    $flags.ZF := v1.value == 0;
    $flags.SF := v1.svalue < 0;
    $flags.CF := 0;
    $flags.OF := 0;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

level(2) pattern {
    asm or $0, $0;
} code {
    renew $0 as v1;
    commit v1;
    $flags.SF := 0;
    $flags.ZF := v1.value == 0;
    $flags.OF := 0;
    $flags.CF := 0;
    $flags.PF := unknown;
    $flags.AF := unknown;
}

level(2) pattern {
    asm test $0, $0;
} code {
    renew $0 as v1;
    commit v1;
    $flags.ZF := v1.value == 0;
    $flags.SF := v1.svalue < 0;
    $flags.CF := 0;
    $flags.OF := 0;
    $flags.PF := unknown;
    $flags.AF := unknown;
}

level(2) pattern {
    asm dec $0;
    asm dec $0;
    asm dec $0;
} code {
    renew $0 as v1;
    commit v1;
    renew v1 as v2;
    v2.value := v1.value - 3;
    commit v2;
    $flags.SF := v2.svalue < 0;
    $flags.ZF := v2.value == 0;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

level(2) pattern {
    asm dec $0;
    asm dec $0;
} code {
    renew $0 as v1;
    commit v1;
    renew v1 as v2;
    v2.value := v1.value - 2;
    commit v2;
    $flags.SF := v2.svalue < 0;
    $flags.ZF := v2.value == 0;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

level(2) pattern {
    asm inc $0;
    asm inc $0;
    asm inc $0;
} code {
    renew $0 as v1;
    commit v1;
    renew v1 as v2;
    v2.value := v1.value + 3;
    commit v2;
    $flags.SF := v2.svalue < 0;
    $flags.ZF := v2.value == 0;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

level(2) pattern {
    asm inc $0;
    asm inc $0;
} code {
    renew $0 as v1;
    commit v1;
    renew v1 as v2;
    v2.value := v1.value + 2;
    commit v2;
    $flags.SF := v2.svalue < 0;
    $flags.ZF := v2.value == 0;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

////////////////////////////////////////////////////////////////////////////
// update's

//
// updating low bytes
//

pattern {
    update $cpu.al;
} code {
    renew $cpu.al as v1;
    commit v1;
    renew $cpu.ah as v2;
    commit v2;
    renew $cpu.ax as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFF00));
    commit v3;
    update_upward $cpu.ax;
    // dx:ax
    renew $cpu.dx as v4;
    commit v4;
    renew $cpu.ax as v5;
    commit v5;
    reset $cpu.dx_ax as v6;
    v6.uvalue := (v5.uvalue | (v4.uvalue << 16));
    commit v6;
    // edx:eax
    renew $cpu.edx as v7;
    commit v7;
    renew $cpu.eax as v8;
    commit v8;
    reset $cpu.edx_eax as v9;
    v9.uvalue := (v8.uvalue | (v7.uvalue << 32));
    commit v9;
    // rdx:rax
    renew $cpu.rdx as v10;
    commit v10;
    renew $cpu.rax as v11;
    commit v11;
    reset $cpu.rdx_rax as v12;
    v12.uvalue := (v11.uvalue | (v10.uvalue << 64));
    commit v12;
}

pattern {
    update $cpu.bl;
} code {
    renew $cpu.bl as v1;
    commit v1;
    renew $cpu.bh as v2;
    commit v2;
    renew $cpu.bx as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFF00));
    commit v3;
    update_upward $cpu.bx;
}

pattern {
    update $cpu.cl;
} code {
    renew $cpu.cl as v1;
    commit v1;
    renew $cpu.ch as v2;
    commit v2;
    renew $cpu.cx as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFF00));
    commit v3;
    update_upward $cpu.cx;
}

pattern {
    update $cpu.dl;
} code {
    renew $cpu.dl as v1;
    commit v1;
    renew $cpu.dh as v2;
    commit v2;
    renew $cpu.dx as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFF00));
    commit v3;
    update_upward $cpu.dx;
    // dx:ax
    renew $cpu.dx as v4;
    commit v4;
    renew $cpu.ax as v5;
    commit v5;
    reset $cpu.dx_ax as v6;
    v6.uvalue := (v5.uvalue | (v4.uvalue << 16));
    commit v6;
    // edx:eax
    renew $cpu.edx as v7;
    commit v7;
    renew $cpu.eax as v8;
    commit v8;
    reset $cpu.edx_eax as v9;
    v9.uvalue := (v8.uvalue | (v7.uvalue << 32));
    commit v9;
    // rdx:rax
    renew $cpu.rdx as v10;
    commit v10;
    renew $cpu.rax as v11;
    commit v11;
    reset $cpu.rdx_rax as v12;
    v12.uvalue := (v11.uvalue | (v10.uvalue << 64));
    commit v12;
}

pattern {
    update $cpu.dil;
} code {
    renew $cpu.dil as v1;
    commit v1;
    renew $cpu.di as v2;
    v2.uvalue := (v1.uvalue | (v2.uvalue & 0xFF00));
    commit v2;
    update_upward $cpu.di;
}

pattern {
    update $cpu.sil;
} code {
    renew $cpu.sil as v1;
    commit v1;
    renew $cpu.si as v2;
    v2.uvalue := (v1.uvalue | (v2.uvalue & 0xFF00));
    commit v2;
    update_upward $cpu.si;
}

pattern {
    update $cpu.bpl;
} code {
    renew $cpu.bpl as v1;
    commit v1;
    renew $cpu.bp as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.value << 8));
    commit v3;
    update_upward $cpu.bp;
}

pattern {
    update $cpu.spl;
} code {
    renew $cpu.spl as v1;
    commit v1;
    renew $cpu.sp as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFF00));
    commit v3;
    update_upward $cpu.sp;
}

pattern {
    update $cpu.r8l;
} code {
    renew $cpu.r8l as v1;
    commit v1;
    renew $cpu.r8w as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFF00));
    commit v3;
    update_upward $cpu.r8w;
}

pattern {
    update $cpu.r9l;
} code {
    renew $cpu.r9l as v1;
    commit v1;
    renew $cpu.r9w as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFF00));
    commit v3;
    update_upward $cpu.r9w;
}

pattern {
    update $cpu.r10l;
} code {
    renew $cpu.r10l as v1;
    commit v1;
    renew $cpu.r10w as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFF00));
    commit v3;
    update_upward $cpu.r10w;
}

pattern {
    update $cpu.r11l;
} code {
    renew $cpu.r11l as v1;
    commit v1;
    renew $cpu.r11w as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFF00));
    commit v3;
    update_upward $cpu.r11w;
}

pattern {
    update $cpu.r12l;
} code {
    renew $cpu.r12l as v1;
    commit v1;
    renew $cpu.r12w as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFF00));
    commit v3;
    update_upward $cpu.r12w;
}

pattern {
    update $cpu.r13l;
} code {
    renew $cpu.r13l as v1;
    commit v1;
    renew $cpu.r13w as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFF00));
    commit v3;
    update_upward $cpu.r13w;
}

pattern {
    update $cpu.r14l;
} code {
    renew $cpu.r14l as v1;
    commit v1;
    renew $cpu.r14w as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFF00));
    commit v3;
    update_upward $cpu.r14w;
}

pattern {
    update $cpu.r15l;
} code {
    renew $cpu.r15l as v1;
    commit v1;
    renew $cpu.r15w as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFF00));
    commit v3;
    update_upward $cpu.r15w;
}

//
// updating high bytes
//

pattern {
    update $cpu.ah;
} code {
    renew $cpu.al as v1;
    commit v1;
    renew $cpu.ah as v2;
    commit v2;
    renew $cpu.ax as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue << 8));
    commit v3;
    update_upward $cpu.ax;
    // dx:ax
    renew $cpu.dx as v4;
    commit v4;
    renew $cpu.ax as v5;
    commit v5;
    reset $cpu.dx_ax as v6;
    v6.uvalue := (v5.uvalue | (v4.uvalue << 16));
    commit v6;
    // edx:eax
    renew $cpu.edx as v7;
    commit v7;
    renew $cpu.eax as v8;
    commit v8;
    reset $cpu.edx_eax as v9;
    v9.uvalue := (v8.uvalue | (v7.uvalue << 32));
    commit v9;
    // rdx:rax
    renew $cpu.rdx as v10;
    commit v10;
    renew $cpu.rax as v11;
    commit v11;
    reset $cpu.rdx_rax as v12;
    v12.uvalue := (v11.uvalue | (v10.uvalue << 64));
    commit v12;
}

pattern {
    update $cpu.bh;
} code {
    renew $cpu.bl as v1;
    commit v1;
    renew $cpu.bh as v2;
    commit v2;
    renew $cpu.bx as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue << 8));
    commit v3;
    update_upward $cpu.bx;
}

pattern {
    update $cpu.ch;
} code {
    renew $cpu.cl as v1;
    commit v1;
    renew $cpu.ch as v2;
    commit v2;
    renew $cpu.cx as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue << 8));
    commit v3;
    update_upward $cpu.cx;
}

pattern {
    update $cpu.dh;
} code {
    renew $cpu.dl as v1;
    commit v1;
    renew $cpu.dh as v2;
    commit v2;
    renew $cpu.dx as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue << 8));
    commit v3;
    update_upward $cpu.dx;
    // dx:ax
    renew $cpu.dx as v4;
    commit v4;
    renew $cpu.ax as v5;
    commit v5;
    reset $cpu.dx_ax as v6;
    v6.uvalue := (v5.uvalue | (v4.uvalue << 16));
    commit v6;
    // edx:eax
    renew $cpu.edx as v7;
    commit v7;
    renew $cpu.eax as v8;
    commit v8;
    reset $cpu.edx_eax as v9;
    v9.uvalue := (v8.uvalue | (v7.uvalue << 32));
    commit v9;
    // rdx:rax
    renew $cpu.rdx as v10;
    commit v10;
    renew $cpu.rax as v11;
    commit v11;
    reset $cpu.rdx_rax as v12;
    v12.uvalue := (v11.uvalue | (v10.uvalue << 64));
    commit v12;
}

//
// updating words upward
//

pattern {
    update_upward $cpu.ax;
} code {
    renew $cpu.ax as v1;
    commit v1;
    renew $cpu.eax as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFF0000));
    commit v3;
    update_upward $cpu.eax;
}

pattern {
    update_upward $cpu.bx;
} code {
    renew $cpu.bx as v1;
    commit v1;
    renew $cpu.ebx as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFF0000));
    commit v3;
    update_upward $cpu.ebx;
}

pattern {
    update_upward $cpu.cx;
} code {
    renew $cpu.cx as v1;
    commit v1;
    renew $cpu.ecx as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFF0000));
    commit v3;
    update_upward $cpu.ecx;
}

pattern {
    update_upward $cpu.dx;
} code {
    renew $cpu.ax as v1;
    commit v1;
    renew $cpu.dx as v2;
    commit v2;
    renew $cpu.dx_ax as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFF0000));
    commit v3;
    renew $cpu.edx as v4;
    commit v4;
    renew v4 as v5;
    v5.uvalue := (v1.uvalue | (v4.uvalue & 0xFFFF0000));
    commit v5;
    update_upward $cpu.edx;
}

pattern {
    update_upward $cpu.di;
} code {
    renew $cpu.di as v1;
    commit v1;
    renew $cpu.edi as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFF0000));
    commit v3;
    update_upward $cpu.edi;
}

pattern {
    update_upward $cpu.si;
} code {
    renew $cpu.si as v1;
    commit v1;
    renew $cpu.esi as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFF0000));
    commit v3;
    update_upward $cpu.esi;
}

pattern {
    update_upward $cpu.bp;
} code {
    renew $cpu.bp as v1;
    commit v1;
    renew $cpu.ebp as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFF0000));
    commit v3;
    update_upward $cpu.ebp;
}

pattern {
    update_upward $cpu.sp;
} code {
    renew $cpu.sp as v1;
    commit v1;
    renew $cpu.esp as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFF0000));
    commit v3;
    update_upward $cpu.esp;
}

pattern {
    update_upward $cpu.r8w;
} code {
    renew $cpu.r8w as v1;
    commit v1;
    renew $cpu.r8d as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFF0000));
    commit v3;
    update_upward $cpu.r8d;
}

pattern {
    update_upward $cpu.r9w;
} code {
    renew $cpu.r9w as v1;
    commit v1;
    renew $cpu.r9d as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFF0000));
    commit v3;
    update_upward $cpu.r9d;
}

pattern {
    update_upward $cpu.r10w;
} code {
    renew $cpu.r10w as v1;
    commit v1;
    renew $cpu.r10d as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFF0000));
    commit v3;
    update_upward $cpu.r10d;
}

pattern {
    update_upward $cpu.r11w;
} code {
    renew $cpu.r11w as v1;
    commit v1;
    renew $cpu.r11d as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFF0000));
    commit v3;
    update_upward $cpu.r11d;
}

pattern {
    update_upward $cpu.r12w;
} code {
    renew $cpu.r12w as v1;
    commit v1;
    renew $cpu.r12d as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFF0000));
    commit v3;
    update_upward $cpu.r12d;
}

pattern {
    update_upward $cpu.r13w;
} code {
    renew $cpu.r13w as v1;
    commit v1;
    renew $cpu.r13d as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFF0000));
    commit v3;
    update_upward $cpu.r13d;
}

pattern {
    update_upward $cpu.r14w;
} code {
    renew $cpu.r14w as v1;
    commit v1;
    renew $cpu.r14d as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFF0000));
    commit v3;
    update_upward $cpu.r14d;
}

pattern {
    update_upward $cpu.r15w;
} code {
    renew $cpu.r15w as v1;
    commit v1;
    renew $cpu.r15d as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFF0000));
    commit v3;
    update_upward $cpu.r15d;
}

//
// updating words downward
//

pattern {
    update_downward $cpu.ax;
} code {
    renew $cpu.ax as v1;
    commit v1;
    renew $cpu.al as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    renew $cpu.ah as v3;
    v3.uvalue := (v1.uvalue >> 8) & 0xFF;
    commit v3;
}

pattern {
    update_downward $cpu.bx;
} code {
    renew $cpu.bx as v1;
    commit v1;
    renew $cpu.bl as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    renew $cpu.bh as v3;
    v3.uvalue := (v1.uvalue >> 8) & 0xFF;
    commit v3;
}

pattern {
    update_downward $cpu.cx;
} code {
    renew $cpu.cx as v1;
    commit v1;
    renew $cpu.cl as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    renew $cpu.ch as v3;
    v3.uvalue := (v1.uvalue >> 8) & 0xFF;
    commit v3;
}

pattern {
    update_downward $cpu.dx;
} code {
    renew $cpu.dx as v1;
    commit v1;
    renew $cpu.dl as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    renew $cpu.dh as v3;
    v3.uvalue := (v1.uvalue >> 8) & 0xFF;
    commit v3;
}

pattern {
    update_downward $cpu.di;
} code {
    renew $cpu.di as v1;
    commit v1;
    renew $cpu.dil as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
}

pattern {
    update_downward $cpu.si;
} code {
    renew $cpu.si as v1;
    commit v1;
    renew $cpu.sil as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
}

pattern {
    update_downward $cpu.bp;
} code {
    renew $cpu.bp as v1;
    commit v1;
    renew $cpu.bpl as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
}

pattern {
    update_downward $cpu.sp;
} code {
    renew $cpu.sp as v1;
    commit v1;
    renew $cpu.spl as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
}

pattern {
    update_downward $cpu.r8w;
} code {
    renew $cpu.r8w as v1;
    commit v1;
    renew $cpu.r8l as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
}

pattern {
    update_downward $cpu.r9w;
} code {
    renew $cpu.r9w as v1;
    commit v1;
    renew $cpu.r9l as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
}

pattern {
    update_downward $cpu.r10w;
} code {
    renew $cpu.r10w as v1;
    commit v1;
    renew $cpu.r10l as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
}

pattern {
    update_downward $cpu.r11w;
} code {
    renew $cpu.r11w as v1;
    commit v1;
    renew $cpu.r11l as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
}

pattern {
    update_downward $cpu.r12w;
} code {
    renew $cpu.r12w as v1;
    commit v1;
    renew $cpu.r12l as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
}

pattern {
    update_downward $cpu.r13w;
} code {
    renew $cpu.r13w as v1;
    commit v1;
    renew $cpu.r13l as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
}

pattern {
    update_downward $cpu.r14w;
} code {
    renew $cpu.r14w as v1;
    commit v1;
    renew $cpu.r14l as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
}

pattern {
    update_downward $cpu.r15w;
} code {
    renew $cpu.r15w as v1;
    commit v1;
    renew $cpu.r15l as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
}

//
// updating words
//

pattern {
    update $cpu.ax;
} code {
    update_downward $cpu.ax;
    update_upward $cpu.ax;
    // dx:ax
    renew $cpu.dx as v1;
    commit v1;
    renew $cpu.ax as v2;
    commit v2;
    reset $cpu.dx_ax as v3;
    v3.uvalue := (v2.uvalue | (v1.uvalue << 16));
    commit v3;
    // edx:eax
    renew $cpu.edx as v4;
    commit v4;
    renew $cpu.eax as v5;
    commit v5;
    reset $cpu.edx_eax as v6;
    v6.uvalue := (v5.uvalue | (v4.uvalue << 32));
    commit v6;
    // rdx:rax
    renew $cpu.rdx as v7;
    commit v7;
    renew $cpu.rax as v8;
    commit v8;
    reset $cpu.rdx_rax as v9;
    v9.uvalue := (v8.uvalue | (v7.uvalue << 64));
    commit v9;
}

pattern {
    update $cpu.bx;
} code {
    update_downward $cpu.bx;
    update_upward $cpu.bx;
}

pattern {
    update $cpu.cx;
} code {
    update_downward $cpu.cx;
    update_upward $cpu.cx;
}

pattern {
    update $cpu.dx;
} code {
    update_downward $cpu.dx;
    update_upward $cpu.dx;
    // dx:ax
    renew $cpu.dx as v1;
    commit v1;
    renew $cpu.ax as v2;
    commit v2;
    reset $cpu.dx_ax as v3;
    v3.uvalue := (v2.uvalue | (v1.uvalue << 16));
    commit v3;
    // edx:eax
    renew $cpu.edx as v4;
    commit v4;
    renew $cpu.eax as v5;
    commit v5;
    reset $cpu.edx_eax as v6;
    v6.uvalue := (v5.uvalue | (v4.uvalue << 32));
    commit v6;
    // rdx:rax
    renew $cpu.rdx as v7;
    commit v7;
    renew $cpu.rax as v8;
    commit v8;
    reset $cpu.rdx_rax as v9;
    v9.uvalue := (v8.uvalue | (v7.uvalue << 64));
    commit v9;
}

pattern {
    update $cpu.di;
} code {
    update_downward $cpu.di;
    update_upward $cpu.di;
}

pattern {
    update $cpu.si;
} code {
    update_downward $cpu.si;
    update_upward $cpu.si;
}

pattern {
    update $cpu.bp;
} code {
    update_downward $cpu.bp;
    update_upward $cpu.bp;
}

pattern {
    update $cpu.sp;
} code {
    update_downward $cpu.sp;
    update_upward $cpu.sp;
}

pattern {
    update $cpu.r8w;
} code {
    update_downward $cpu.r8w;
    update_upward $cpu.r8w;
}

pattern {
    update $cpu.r9w;
} code {
    update_downward $cpu.r9w;
    update_upward $cpu.r9w;
}

pattern {
    update $cpu.r10w;
} code {
    update_downward $cpu.r10w;
    update_upward $cpu.r10w;
}

pattern {
    update $cpu.r11w;
} code {
    update_downward $cpu.r11w;
    update_upward $cpu.r11w;
}

pattern {
    update $cpu.r12w;
} code {
    update_downward $cpu.r12w;
    update_upward $cpu.r12w;
}

pattern {
    update $cpu.r13w;
} code {
    update_downward $cpu.r13w;
    update_upward $cpu.r13w;
}

pattern {
    update $cpu.r14w;
} code {
    update_downward $cpu.r14w;
    update_upward $cpu.r14w;
}

pattern {
    update $cpu.r15w;
} code {
    update_downward $cpu.r15w;
    update_upward $cpu.r15w;
}

//
// updating dwords upward
//

pattern {
    update_upward $cpu.eax;
} code {
    renew $cpu.eax as v1;
    commit v1;
    renew $cpu.rax as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFFFFFF00000000));
    commit v3;
}

pattern {
    update_upward $cpu.ebx;
} code {
    renew $cpu.ebx as v1;
    commit v1;
    renew $cpu.rbx as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFFFFFF00000000));
    commit v3;
}

pattern {
    update_upward $cpu.ecx;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    renew $cpu.rcx as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFFFFFF00000000));
    commit v3;
}

pattern {
    update_upward $cpu.edx;
} code {
    renew $cpu.edx as v1;
    commit v1;
    renew $cpu.rdx as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFFFFFF00000000));
    commit v3;
    renew $cpu.edx_eax as v4;
    commit v4;
}

pattern {
    update_upward $cpu.edi;
} code {
    renew $cpu.edi as v1;
    commit v1;
    renew $cpu.rdi as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFFFFFF00000000));
    commit v3;
}

pattern {
    update_upward $cpu.esi;
} code {
    renew $cpu.esi as v1;
    commit v1;
    renew $cpu.rsi as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFFFFFF00000000));
    commit v3;
}

pattern {
    update_upward $cpu.ebp;
} code {
    renew $cpu.ebp as v1;
    commit v1;
    renew $cpu.rbp as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFFFFFF00000000));
    commit v3;
}

pattern {
    update_upward $cpu.esp;
} code {
    renew $cpu.esp as v1;
    commit v1;
    renew $cpu.rsp as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFFFFFF00000000));
    commit v3;
}

pattern {
    update_upward $cpu.r8d;
} code {
    renew $cpu.r8d as v1;
    commit v1;
    renew $cpu.r8 as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFFFFFF00000000));
    commit v3;
}

pattern {
    update_upward $cpu.r9d;
} code {
    renew $cpu.r9d as v1;
    commit v1;
    renew $cpu.r9 as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFFFFFF00000000));
    commit v3;
}

pattern {
    update_upward $cpu.r10d;
} code {
    renew $cpu.r10d as v1;
    commit v1;
    renew $cpu.r10 as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFFFFFF00000000));
    commit v3;
}

pattern {
    update_upward $cpu.r11d;
} code {
    renew $cpu.r11d as v1;
    commit v1;
    renew $cpu.r11 as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFFFFFF00000000));
    commit v3;
}

pattern {
    update_upward $cpu.r12d;
} code {
    renew $cpu.r12d as v1;
    commit v1;
    renew $cpu.r12 as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFFFFFF00000000));
    commit v3;
}

pattern {
    update_upward $cpu.r13d;
} code {
    renew $cpu.r13d as v1;
    commit v1;
    renew $cpu.r13 as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFFFFFF00000000));
    commit v3;
}

pattern {
    update_upward $cpu.r14d;
} code {
    renew $cpu.r14d as v1;
    commit v1;
    renew $cpu.r14 as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFFFFFF00000000));
    commit v3;
}

pattern {
    update_upward $cpu.r15d;
} code {
    renew $cpu.r15d as v1;
    commit v1;
    renew $cpu.r15 as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFFFFFF00000000));
    commit v3;
}

pattern {
    update_upward $cpu.eip;
} code {
    renew $cpu.eip as v1;
    commit v1;
    renew $cpu.rip as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFFFFFF00000000));
    commit v3;
}

pattern {
    update_upward $cpu.eflags;
} code {
    renew $cpu.eflags as v1;
    commit v1;
    renew $cpu.rflags as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | (v2.uvalue & 0xFFFFFFFF00000000));
    commit v3;
}

//
// updating dwords downward
//

pattern {
    update_downward $cpu.eax;
} code {
    renew $cpu.eax as v1;
    commit v1;
    renew $cpu.ax as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.ax;
}

pattern {
    update_downward $cpu.ebx;
} code {
    renew $cpu.ebx as v1;
    commit v1;
    renew $cpu.bx as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.bx;
}

pattern {
    update_downward $cpu.ecx;
} code {
    renew $cpu.ecx as v1;
    commit v1;
    renew $cpu.cx as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.cx;
}

pattern {
    update_downward $cpu.edx;
} code {
    renew $cpu.edx as v1;
    commit v1;
    renew $cpu.dx as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.dx;
}

pattern {
    update_downward $cpu.edi;
} code {
    renew $cpu.edi as v1;
    commit v1;
    renew $cpu.di as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.di;
}

pattern {
    update_downward $cpu.esi;
} code {
    renew $cpu.esi as v1;
    commit v1;
    renew $cpu.si as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.si;
}

pattern {
    update_downward $cpu.ebp;
} code {
    renew $cpu.ebp as v1;
    commit v1;
    renew $cpu.bp as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.bp;
}

pattern {
    update_downward $cpu.esp;
} code {
    renew $cpu.esp as v1;
    commit v1;
    renew $cpu.sp as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.sp;
}

pattern {
    update_downward $cpu.r8d;
} code {
    renew $cpu.r8d as v1;
    commit v1;
    renew $cpu.r8w as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.r8w;
}

pattern {
    update_downward $cpu.r9d;
} code {
    renew $cpu.r9d as v1;
    commit v1;
    renew $cpu.r9w as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.r9w;
}

pattern {
    update_downward $cpu.r10d;
} code {
    renew $cpu.r10d as v1;
    commit v1;
    renew $cpu.r10w as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.r10w;
}

pattern {
    update_downward $cpu.r11d;
} code {
    renew $cpu.r11d as v1;
    commit v1;
    renew $cpu.r11w as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.r11w;
}

pattern {
    update_downward $cpu.r12d;
} code {
    renew $cpu.r12d as v1;
    commit v1;
    renew $cpu.r12w as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.r12w;
}

pattern {
    update_downward $cpu.r13d;
} code {
    renew $cpu.r13d as v1;
    commit v1;
    renew $cpu.r13w as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.r13w;
}

pattern {
    update_downward $cpu.r14d;
} code {
    renew $cpu.r14d as v1;
    commit v1;
    renew $cpu.r14w as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.r14w;
}

pattern {
    update_downward $cpu.r15d;
} code {
    renew $cpu.r15d as v1;
    commit v1;
    renew $cpu.r15w as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.r15w;
}

pattern {
    update_downward $cpu.esp;
} code {
    renew $cpu.esp as v1;
    commit v1;
    renew $cpu.sp as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.sp;
}

pattern {
    update_downward $cpu.eip;
} code {
    renew $cpu.eip as v1;
    commit v1;
    renew $cpu.ip as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    update_downward $cpu.ip;
}

pattern {
    update_downward $cpu.eflags;
} code {
    renew $cpu.eflags as v1;
    commit v1;
    renew $cpu.flags as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
}

//
// updating dwords
//

pattern {
    update $cpu.eax;
} code {
    update_downward $cpu.eax;
    update_upward $cpu.eax;
    // dx:ax
    renew $cpu.dx as v1;
    commit v1;
    renew $cpu.ax as v2;
    commit v2;
    reset $cpu.dx_ax as v3;
    v3.uvalue := (v2.uvalue | (v1.uvalue << 16));
    commit v3;
    // edx:eax
    renew $cpu.edx as v4;
    commit v4;
    renew $cpu.eax as v5;
    commit v5;
    reset $cpu.edx_eax as v6;
    v6.uvalue := (v5.uvalue | (v4.uvalue << 32));
    commit v6;
    // rdx:rax
    renew $cpu.rdx as v7;
    commit v7;
    renew $cpu.rax as v8;
    commit v8;
    reset $cpu.rdx_rax as v9;
    v9.uvalue := (v8.uvalue | (v7.uvalue << 64));
    commit v9;
}

pattern {
    update $cpu.ebx;
} code {
    update_downward $cpu.ebx;
    update_upward $cpu.ebx;
}

pattern {
    update $cpu.ecx;
} code {
    update_downward $cpu.ecx;
    update_upward $cpu.ecx;
}

pattern {
    update $cpu.edx;
} code {
    update_downward $cpu.edx;
    update_upward $cpu.edx;
    // dx:ax
    renew $cpu.dx as v1;
    commit v1;
    renew $cpu.ax as v2;
    commit v2;
    reset $cpu.dx_ax as v3;
    v3.uvalue := (v2.uvalue | (v1.uvalue << 16));
    commit v3;
    // edx:eax
    renew $cpu.edx as v4;
    commit v4;
    renew $cpu.eax as v5;
    commit v5;
    reset $cpu.edx_eax as v6;
    v6.uvalue := (v5.uvalue | (v4.uvalue << 32));
    commit v6;
    // rdx:rax
    renew $cpu.rdx as v7;
    commit v7;
    renew $cpu.rax as v8;
    commit v8;
    reset $cpu.rdx_rax as v9;
    v9.uvalue := (v8.uvalue | (v7.uvalue << 64));
    commit v9;
}

pattern {
    update $cpu.edi;
} code {
    update_downward $cpu.edi;
    update_upward $cpu.edi;
}

pattern {
    update $cpu.esi;
} code {
    update_downward $cpu.esi;
    update_upward $cpu.esi;
}

pattern {
    update $cpu.ebp;
} code {
    update_downward $cpu.ebp;
    update_upward $cpu.ebp;
}

pattern {
    update $cpu.esp;
} code {
    update_downward $cpu.esp;
    update_upward $cpu.esp;
}

pattern {
    update $cpu.r8d;
} code {
    update_downward $cpu.r8d;
    update_upward $cpu.r8d;
}

pattern {
    update $cpu.r9d;
} code {
    update_downward $cpu.r9d;
    update_upward $cpu.r9d;
}

pattern {
    update $cpu.r10d;
} code {
    update_downward $cpu.r10d;
    update_upward $cpu.r10d;
}

pattern {
    update $cpu.r11d;
} code {
    update_downward $cpu.r11d;
    update_upward $cpu.r11d;
}

pattern {
    update $cpu.r12d;
} code {
    update_downward $cpu.r12d;
    update_upward $cpu.r12d;
}

pattern {
    update $cpu.r13d;
} code {
    update_downward $cpu.r13d;
    update_upward $cpu.r13d;
}

pattern {
    update $cpu.r14d;
} code {
    update_downward $cpu.r14d;
    update_upward $cpu.r14d;
}

pattern {
    update $cpu.r15d;
} code {
    update_downward $cpu.r15d;
    update_upward $cpu.r15d;
}

pattern {
    update $cpu.eip;
} code {
    update_downward $cpu.eip;
    update_upward $cpu.eip;
}

pattern {
    update $cpu.eflags;
} code {
    update_downward $cpu.eflags;
    update_upward $cpu.eflags;
}

//
// updating qwords downward
//

pattern {
    update_downward $cpu.rax;
} code {
    renew $cpu.rax as v1;
    commit v1;
    renew $cpu.eax as v2;
    v2.uvalue := (v1.uvalue & 0xFFFFFFFF);
    commit v2;
    update_downward $cpu.eax;
}

pattern {
    update_downward $cpu.rbx;
} code {
    renew $cpu.rbx as v1;
    commit v1;
    renew $cpu.ebx as v2;
    v2.uvalue := (v1.uvalue & 0xFFFFFFFF);
    commit v2;
    update_downward $cpu.ebx;
}

pattern {
    update_downward $cpu.rcx;
} code {
    renew $cpu.rcx as v1;
    commit v1;
    renew $cpu.ecx as v2;
    v2.uvalue := (v1.uvalue & 0xFFFFFFFF);
    commit v2;
    update_downward $cpu.ecx;
}

pattern {
    update_downward $cpu.rdx;
} code {
    renew $cpu.rdx as v1;
    commit v1;
    renew $cpu.edx as v2;
    v2.uvalue := (v1.uvalue & 0xFFFFFFFF);
    commit v2;
    update_downward $cpu.edx;
}

pattern {
    update_downward $cpu.rdi;
} code {
    renew $cpu.rdi as v1;
    commit v1;
    renew $cpu.edi as v2;
    v2.uvalue := (v1.uvalue & 0xFFFFFFFF);
    commit v2;
    update_downward $cpu.edi;
}

pattern {
    update_downward $cpu.rsi;
} code {
    renew $cpu.rsi as v1;
    commit v1;
    renew $cpu.esi as v2;
    v2.uvalue := (v1.uvalue & 0xFFFFFFFF);
    commit v2;
    update_downward $cpu.esi;
}

pattern {
    update_downward $cpu.rbp;
} code {
    renew $cpu.rsi as v1;
    commit v1;
    renew $cpu.esi as v2;
    v2.uvalue := (v1.uvalue & 0xFFFFFFFF);
    commit v2;
    update_downward $cpu.esi;
}

pattern {
    update_downward $cpu.rsp;
} code {
    renew $cpu.rsp as v1;
    commit v1;
    renew $cpu.esp as v2;
    v2.uvalue := (v1.uvalue & 0xFFFFFFFF);
    commit v2;
    update_downward $cpu.esp;
}

pattern {
    update_downward $cpu.r8;
} code {
    renew $cpu.r8 as v1;
    commit v1;
    renew $cpu.r8d as v2;
    v2.uvalue := (v1.uvalue & 0xFFFFFFFF);
    commit v2;
    update_downward $cpu.r8d;
}

pattern {
    update_downward $cpu.r9;
} code {
    renew $cpu.r9 as v1;
    commit v1;
    renew $cpu.r9d as v2;
    v2.uvalue := (v1.uvalue & 0xFFFFFFFF);
    commit v2;
    update_downward $cpu.r9d;
}

pattern {
    update_downward $cpu.r10;
} code {
    renew $cpu.r10 as v1;
    commit v1;
    renew $cpu.r10d as v2;
    v2.uvalue := (v1.uvalue & 0xFFFFFFFF);
    commit v2;
    update_downward $cpu.r10d;
}

pattern {
    update_downward $cpu.r11;
} code {
    renew $cpu.r11 as v1;
    commit v1;
    renew $cpu.r11d as v2;
    v2.uvalue := (v1.uvalue & 0xFFFFFFFF);
    commit v2;
    update_downward $cpu.r11d;
}

pattern {
    update_downward $cpu.r12;
} code {
    renew $cpu.r12 as v1;
    commit v1;
    renew $cpu.r12d as v2;
    v2.uvalue := (v1.uvalue & 0xFFFFFFFF);
    commit v2;
    update_downward $cpu.r12d;
}

pattern {
    update_downward $cpu.r13;
} code {
    renew $cpu.r13 as v1;
    commit v1;
    renew $cpu.r13d as v2;
    v2.uvalue := (v1.uvalue & 0xFFFFFFFF);
    commit v2;
    update_downward $cpu.r13d;
}

pattern {
    update_downward $cpu.r14;
} code {
    renew $cpu.r14 as v1;
    commit v1;
    renew $cpu.r14d as v2;
    v2.uvalue := (v1.uvalue & 0xFFFFFFFF);
    commit v2;
    update_downward $cpu.r14d;
}

pattern {
    update_downward $cpu.r15;
} code {
    renew $cpu.r15 as v1;
    commit v1;
    renew $cpu.r15d as v2;
    v2.uvalue := (v1.uvalue & 0xFFFFFFFF);
    commit v2;
    update_downward $cpu.r15d;
}

pattern {
    update_downward $cpu.rip;
} code {
    renew $cpu.rip as v1;
    commit v1;
    renew $cpu.eip as v2;
    v2.uvalue := (v1.uvalue & 0xFFFFFFFF);
    commit v2;
    update_downward $cpu.eip;
}

pattern {
    update_downward $cpu.rflags;
} code {
    renew $cpu.rflags as v1;
    commit v1;
    renew $cpu.eflags as v2;
    v2.uvalue := (v1.uvalue & 0xFFFFFFFF);
    commit v2;
    update_downward $cpu.eflags;
}

//
// updating qwords
//

pattern {
    update $cpu.rax;
} code {
    update_downward $cpu.rax;
    // dx:ax
    renew $cpu.dx as v3;
    commit v3;
    renew $cpu.ax as v4;
    commit v4;
    reset $cpu.dx_ax as v5;
    v5.uvalue := (v4.uvalue | (v3.uvalue << 16));
    commit v5;
    // edx:eax
    renew $cpu.edx as v6;
    commit v6;
    renew $cpu.eax as v7;
    commit v7;
    reset $cpu.edx_eax as v8;
    v8.uvalue := (v7.uvalue | (v6.uvalue << 32));
    commit v8;
    // rdx:rax
    renew $cpu.rdx as v9;
    commit v9;
    renew $cpu.rax as v10;
    commit v10;
    reset $cpu.rdx_rax as v11;
    v11.uvalue := (v10.uvalue | (v9.uvalue << 64));
    commit v11;
}

pattern {
    update $cpu.rbx;
} code {
    update_downward $cpu.rbx;
}

pattern {
    update $cpu.rcx;
} code {
    update_downward $cpu.rcx;
}

pattern {
    update $cpu.rdx;
} code {
    update_downward $cpu.rdx;
    // dx:ax
    renew $cpu.dx as v3;
    commit v3;
    renew $cpu.ax as v4;
    commit v4;
    reset $cpu.dx_ax as v5;
    v5.uvalue := (v4.uvalue | (v3.uvalue << 16));
    commit v5;
    // edx:eax
    renew $cpu.edx as v6;
    commit v6;
    renew $cpu.eax as v7;
    commit v7;
    reset $cpu.edx_eax as v8;
    v8.uvalue := (v7.uvalue | (v6.uvalue << 32));
    commit v8;
    // rdx:rax
    renew $cpu.rdx as v9;
    commit v9;
    renew $cpu.rax as v10;
    commit v10;
    reset $cpu.rdx_rax as v11;
    v11.uvalue := (v10.uvalue | (v9.uvalue << 64));
    commit v11;
}

pattern {
    update $cpu.rdi;
} code {
    update_downward $cpu.rdi;
}

pattern {
    update $cpu.rsi;
} code {
    update_downward $cpu.rsi;
}

pattern {
    update $cpu.rbp;
} code {
    update_downward $cpu.rbp;
}

pattern {
    update $cpu.rsp;
} code {
    update_downward $cpu.rsp;
}

pattern {
    update $cpu.r8;
} code {
    update_downward $cpu.r8;
}

pattern {
    update $cpu.r9;
} code {
    update_downward $cpu.r9;
}

pattern {
    update $cpu.r10;
} code {
    update_downward $cpu.r10;
}

pattern {
    update $cpu.r11;
} code {
    update_downward $cpu.r11;
}

pattern {
    update $cpu.r12;
} code {
    update_downward $cpu.r12;
}

pattern {
    update $cpu.r13;
} code {
    update_downward $cpu.r13;
}

pattern {
    update $cpu.r14;
} code {
    update_downward $cpu.r14;
}

pattern {
    update $cpu.r15;
} code {
    update_downward $cpu.r15;
}

pattern {
    update $cpu.rip;
} code {
    update_downward $cpu.rip;
}

pattern {
    update $cpu.rflags;
} code {
    update_downward $cpu.rflags;
}

//
//
//
pattern {
    update $cpu.rdx, $cpu.rax;
} code {
    update_downward $cpu.rdx;
    update_downward $cpu.rax;
    renew $cpu.dx as v1;
    commit v1;
    renew $cpu.ax as v2;
    commit v2;
    renew $cpu.dx_ax as v3;
    v3.uvalue := (v2.uvalue | (v1.uvalue << 16));
    commit v3;
    renew $cpu.edx as v4;
    commit v4;
    renew $cpu.eax as v5;
    commit v5;
    renew $cpu.edx_eax as v6;
    v6.uvalue := (v5.uvalue | (v4.uvalue << 32));
    commit v6;
    renew $cpu.rdx as v7;
    commit v7;
    renew $cpu.rax as v8;
    commit v8;
    renew $cpu.rdx_rax as v9;
    v9.uvalue := (v8.uvalue | (v7.uvalue << 64));
    commit v9;
}

pattern {
    update $cpu.edx, $cpu.eax;
} code {
    update_downward $cpu.edx;
    update_downward $cpu.eax;
    update_upward $cpu.edx;
    update_upward $cpu.eax;
    renew $cpu.dx as v1;
    commit v1;
    renew $cpu.ax as v2;
    commit v2;
    renew $cpu.dx_ax as v3;
    v3.uvalue := (v2.uvalue | (v1.uvalue << 16));
    commit v3;
    renew $cpu.edx as v4;
    commit v4;
    renew $cpu.eax as v5;
    commit v5;
    renew $cpu.edx_eax as v6;
    v6.uvalue := (v5.uvalue | (v4.uvalue << 32));
    commit v6;
    renew $cpu.rdx as v7;
    commit v7;
    renew $cpu.rax as v8;
    commit v8;
    renew $cpu.rdx_rax as v9;
    v9.uvalue := (v8.uvalue | (v7.uvalue << 64));
    commit v9;
}

pattern {
    update $cpu.dx, $cpu.ax;
} code {
    update_downward $cpu.dx;
    update_downward $cpu.ax;
    update_upward $cpu.dx;
    update_upward $cpu.ax;
    renew $cpu.dx as v1;
    commit v1;
    renew $cpu.ax as v2;
    commit v2;
    renew $cpu.dx_ax as v3;
    v3.uvalue := (v2.uvalue | (v1.uvalue << 16));
    commit v3;
    renew $cpu.edx as v4;
    commit v4;
    renew $cpu.eax as v5;
    commit v5;
    renew $cpu.edx_eax as v6;
    v6.uvalue := (v5.uvalue | (v4.uvalue << 32));
    commit v6;
}

pattern {
    update $0M;
} code {
    static if ($0M.bits == 64) {
        continuous $1M.addr, $1M.addr + 8;
    } else static if ($0M.bits == 32) {
        continuous $1M.addr, $1M.addr + 4;
    } else static if ($0M.bits == 16) {
        continuous $1M.addr, $1M.addr + 2;
    } else static if ($0M.bits == 8) {
        continuous $1M.addr, $1M.addr + 1;
    } else {
        assert(0);
    }
}

////////////////////////////////////////////////////////////////////////////
// instructions

pattern {
    asm adc $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.value := v1.value + v2.value + $flags.CF;
    commit v3;
    $flags.ZF := v3.value == 0;
    $flags.SF := v3.svalue < 0;
    $flags.CF := v3.uvalue < v1.uvalue;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

pattern {
    add $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.value := v1.value + v2.value;
    commit v3;
    $flags.ZF := v3.value == 0;
    $flags.SF := v3.svalue < 0;
    $flags.CF := v3.uvalue < v1.uvalue;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

pattern {
    addnf $0, $1;   // CodeReverse extension
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.value := v1.value + v2.value;
    commit v3;
    update $0;
}

pattern {
    asm and $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.value := (v1.value & v2.value);
    commit v3;
    $flags.ZF := v3.value == 0;
    $flags.SF := v3.svalue < 0;
    $flags.CF := 0;
    $flags.OF := 0;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

pattern {
    asm bswap $0;
} code {
    renew $0 as v1;
    commit v1;
    renew v1 as v2;
    v2.value := $fn._bswap(v1.value);
    commit v2;
    update $0;
}

pattern {
    asm bt $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.value := (v1.value & (1 << v2.value));
    commit v3;
    $flags.CF := v3.value != 0;
    $flags.OF := unknown;
    $flags.SF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

pattern {
    asm btc $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.value := (v1.value & (1 << v2.value));
    commit v3;
    $flags.CF := v3.value != 0;
    if (v3.value) {
        renew v1 as v2;
        v2.value := v1.value & ~(1 << $1.value);
        commit v2;
    } else {
        renew v1 as v3;
        v3.value := v1.value | (1 << $1.value);
        commit v3;
    }
    $flags.OF := unknown;
    $flags.SF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

pattern {
    asm btr $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.value := (v1.value & (1 << v2.value));
    commit v3;
    $flags.CF := v3.value != 0;
    new v3 as v4;
    v4.value := (v1.value & ~(1 << $1.value));
    commit v2;
    $flags.OF := unknown;
    $flags.SF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

pattern {
    asm bts $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.value := (v1.value & (1 << v2.value));
    commit v3;
    $flags.CF := v3.value != 0;
    new v3 as v4;
    v4.value := (v1.value | (1 << v2.value));
    commit v4;
    $flags.OF := unknown;
    $flags.SF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

pattern {
    asm call $0;
} code {
    renew $0 as v1;
    commit v1;
    call v1.cvalue;
}

pattern {
    asm cbw;
} code {
    renew $cpu.al as v1;
    commit v1;
    renew $cpu.ax as v2;
    v2.svalue := v1.svalue;
    commit v2;
    update $cpu.ax;
}

pattern {
    asm cwde;
} code {
    renew $cpu.ax as v1;
    commit v1;
    renew $cpu.eax as v2;
    v2.svalue := v1.svalue;
    commit v2;
    update $cpu.eax;
}

pattern {
    asm cdqe;
} code {
    renew $cpu.eax as v1;
    commit v1;
    renew $cpu.rax as v2;
    v2.svalue := v1.svalue;
    commit v2;
    update $cpu.rax;
}

pattern {
    asm clc
} code {
    $flags.CF := 0;
}

pattern {
    asm cld;
} code {
    $flags.DF := 0;
}

// clflush($m8);

pattern {
    asm cli;
} code {
    $flags.IF := 0;
}

// clts();

pattern {
    asm cmc;
} code {
    if ($flags.CF == 1) {
        $flags.CF := 0;
    } else {
        $flags.CF := 1;
    }
}

pattern {
    asm cmova $0, $1;
} code {
    if ($flags.CF == 0 && $flags.ZF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovae $0, $1;
} code {
    if ($flags.CF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovb $0, $1;
} code {
    if ($flags.CF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovbe $0, $1;
} code {
    if ($flags.CF == 1 || flags.ZF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovc $0, $1;
} code {
    if ($flags.CF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmove $0, $1;
} code {
    if ($flags.ZF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovg $0, $1;
} code {
    if ($flags.ZF == 0 == 1 && $flags.SFeqOF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovge $0, $1;
} code {
    if ($flags.SFeqOF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovl $0, $1;
} code {
    if ($flags.SFeqOF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovle $0, $1;
} code {
    if ($flags.ZF == 1 || $flags.SFeqOF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovna $0, $1;
} code {
    if ($flags.CF == 1 || $flags.ZF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovnae $0, $1;
} code {
    if ($flags.CF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    cmovnb $0, $1;
} code {
    if ($flags.CF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovnbe $0, $1;
} code {
    if ($flags.CF == 0 && $flags.ZF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovnc $0, $1;
} code {
    if ($flags.CF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovne $0, $1;
} code {
    if ($flags.ZF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovng $0, $1;
} code {
    if ($flags.ZF == 1 || $flags.SFeqOF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovnge $0, $1;
} code {
    if ($flags.SFeqOF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovnl $0, $1;
} code {
    if ($flags.SFeqOF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovnle $0, $1;
} code {
    if ($flags.ZF == 0 && $flags.SFeqOF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovno $0, $1;
} code {
    if ($flags.OF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovnp $0, $1;
} code {
    if ($flags.PF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovns $0, $1;
} code {
    if ($flags.SF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovnz $0, $1;
} code {
    if ($flags.ZF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovo $0, $1;
} code {
    if ($flags.OF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovp $0, $1;
} code {
    if ($flags.PF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovpe $0, $1;
} code {
    if ($flags.PF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovpo $0, $1;
} code {
    if ($flags.PF == 0) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovs $0, $1;
} code {
    if ($flags.SF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmovz $0, $1;
} code {
    if ($flags.ZF == 1) {
        renew $0 as v1;
        v1.value := $1.value;
        commit v1;
        update $0;
    }
}

pattern {
    asm cmp $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    $flags.ZF := v1.value == v2.value;
    $flags.SF := v1.svalue < v2.svalue;
    $flags.OF := unknown;
    $flags.CF := v1.uvalue < v2.uvalue;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

pattern {
    asm cmpsb;
} code {
    renew $cpu.rsi as v1;
    v1.type := $type.ptr($type.x8);
    commit v1;
    renew $cpu.rdi as v2;
    v2.type := $type.ptr($type.x8);
    commit v2;
    new v3;
    v3.addr := v1.pvalue;
    v3.bits := 8;
    commit v3;
    new v4;
    v4.addr := v2.pvalue;
    v3.bits := 8;
    commit v4;
    $flags.ZF := v3.value == v4.value;
    $flags.SF := v3.svalue < v4.svalue;
    $flags.OF := unknown;
    $flags.CF := v3.uvalue < v4.uvalue;
    $flags.AF := unknown;
    $flags.PF := unknown;
    if ($flags.DF == 0) {
        renew v1 as v5;
        v5.pvalue := v1.pvalue + 1;
        commit v5;
        renew v2 as v6;
        v6.pvalue := v2.pvalue + 1;
        commit v6;
    } else {
        renew v1 as v5;
        v5.pvalue := v1.pvalue - 1;
        commit v5;
        renew v2 as v6;
        v6.pvalue := v2.pvalue - 1;
        commit v6;
    }
    update $cpu.rdi;
    update $cpu.rsi;
}

pattern {
    asm cmpsw;
} code {
    renew $cpu.rsi as v1;
    v1.type := $type.ptr($type.x16);
    commit v1;
    renew $cpu.rdi as v2;
    v2.type := $type.ptr($type.x16);
    commit v2;
    new v3;
    v3.addr := v1.pvalue;
    v3.bits := 16;
    commit v3;
    new v4;
    v4.addr := v2.pvalue;
    v3.bits := 16;
    commit v4;
    $flags.ZF := v3.value == v4.value;
    $flags.SF := v3.svalue < v4.svalue;
    $flags.OF := unknown;
    $flags.CF := v3.uvalue < v4.uvalue;
    $flags.AF := unknown;
    $flags.PF := unknown;
    if ($flags.DF == 0) {
        renew v1 as v5;
        v5.pvalue := v1.pvalue + 2;
        commit v5;
        renew v2 as v6;
        v6.pvalue := v2.pvalue + 2;
        commit v6;
    } else {
        renew v1 as v5;
        v5.pvalue := v1.pvalue - 2;
        commit v5;
        renew v2 as v6;
        v6.pvalue := v2.pvalue - 2;
        commit v6;
    }
    update $cpu.rdi;
    update $cpu.rsi;
}

pattern {
    asm cmpsd;
} code {
    renew $cpu.rsi as v1;
    v1.type := $type.ptr($type.x32);
    commit v1;
    renew $cpu.rdi as v2;
    v2.type := $type.ptr($type.x32);
    commit v2;
    new v3;
    v3.addr := v1.pvalue;
    v3.bits := 32;
    commit v3;
    new v4;
    v4.addr := v2.pvalue;
    v3.bits := 32;
    commit v4;
    $flags.ZF := v3.value == v4.value;
    $flags.SF := v3.svalue < v4.svalue;
    $flags.OF := unknown;
    $flags.CF := v3.uvalue < v4.uvalue;
    $flags.AF := unknown;
    $flags.PF := unknown;
    if ($flags.DF == 0) {
        renew v1 as v5;
        v5.pvalue := v1.pvalue + 4;
        commit v5;
        renew v2 as v6;
        v6.pvalue := v2.pvalue + 4;
        commit v6;
    } else {
        renew v1 as v5;
        v5.pvalue := v1.pvalue - 4;
        commit v5;
        renew v2 as v6;
        v6.pvalue := v2.pvalue - 4;
        commit v6;
    }
    update $cpu.rdi;
    update $cpu.rsi;
}

pattern {
    asm cmpsq;
} code {
    renew $cpu.rsi as v1;
    v1.type := $type.ptr($type.x64);
    commit v1;
    renew $cpu.rdi as v2;
    v2.type := $type.ptr($type.x64);
    commit v2;
    new v3;
    v3.addr := v1.pvalue;
    v3.bits := 64;
    commit v3;
    new v4;
    v4.addr := v2.pvalue;
    v3.bits := 64;
    commit v4;
    $flags.ZF := v3.value == v4.value;
    $flags.SF := v3.svalue < v4.svalue;
    $flags.OF := unknown;
    $flags.CF := v3.uvalue < v4.uvalue;
    $flags.AF := unknown;
    $flags.PF := unknown;
    if ($flags.DF == 0) {
        renew v1 as v5;
        v5.pvalue := v1.pvalue + 8;
        commit v5;
        renew v2 as v6;
        v6.pvalue := v2.pvalue + 8;
        commit v6;
    } else {
        renew v1 as v5;
        v5.pvalue := v1.pvalue - 8;
        commit v5;
        renew v2 as v6;
        v6.pvalue := v2.pvalue - 8;
        commit v6;
    }
    update $cpu.rdi;
    update $cpu.rsi;
}

pattern {
    asm repe_cmpsb;
} code {
    renew $cpu.rsi as v1;
    v1.type := $type.ptr($type.x8);
    commit v1;
    renew $cpu.rdi as v2;
    v2.type := $type.ptr($type.x8);
    commit v2;
    renew $cpu.rcx as v3;
    commit v3;
    for (;;) {
        join v8 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v6 to v1;
        join v7 to v2;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 8;
        commit v4;
        new v5;
        v5.addr := v2.pvalue;
        v5.bits := 8;
        commit v5;
        $flags.SF := v4.svalue < v5.svalue;
        $flags.CF := v4.uvalue < v5.uvalue;
        $flags.ZF := v4.value == v5.value;
        if ($flags.ZF == 0) {
            break;
        }
        if ($flags.DF == 0) {
            renew v2 as v6;
            v6.pvalue := v2.pvalue + 1;
            commit v6;
        } else {
            renew v2 as v6;
            v6.pvalue := v2.pvalue - 1;
            commit v6;
        }
        renew v3 as v7;
        v7.uvalue := v3.uvalue - 1;
        commit v7;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.OF := unknown;
}

pattern {
    asm repe_cmpsw;
} code {
    renew $cpu.rsi as v1;
    v1.type := $type.ptr($type.x16);
    commit v1;
    renew $cpu.rdi as v2;
    v2.type := $type.ptr($type.x16);
    commit v2;
    renew $cpu.rcx as v3;
    commit v3;
    for (;;) {
        join v8 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v6 to v1;
        join v7 to v2;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 16;
        commit v4;
        new v5;
        v5.addr := v2.pvalue;
        v5.bits := 16;
        commit v5;
        $flags.SF := v4.svalue < v5.svalue;
        $flags.CF := v4.uvalue < v5.uvalue;
        $flags.ZF := v4.value == v5.value;
        if ($flags.ZF == 0) {
            break;
        }
        if ($flags.DF == 0) {
            renew v2 as v6;
            v6.pvalue := v2.pvalue + 2;
            commit v6;
        } else {
            renew v2 as v6;
            v6.pvalue := v2.pvalue - 2;
            commit v6;
        }
        renew v3 as v7;
        v7.uvalue := v3.uvalue - 1;
        commit v7;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.OF := unknown;
}

pattern {
    asm repe_cmpsd;
} code {
    renew $cpu.rsi as v1;
    v1.type := $type.ptr($type.x32);
    commit v1;
    renew $cpu.rdi as v2;
    v2.type := $type.ptr($type.x32);
    commit v2;
    renew $cpu.rcx as v3;
    commit v3;
    for (;;) {
        join v8 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v6 to v1;
        join v7 to v2;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 32;
        commit v4;
        new v5;
        v5.addr := v2.pvalue;
        v5.bits := 32;
        commit v5;
        $flags.SF := v4.svalue < v5.svalue;
        $flags.CF := v4.uvalue < v5.uvalue;
        $flags.ZF := v4.value == v5.value;
        if ($flags.ZF == 0) {
            break;
        }
        if ($flags.DF == 0) {
            renew v2 as v6;
            v6.pvalue := v2.pvalue + 4;
            commit v6;
        } else {
            renew v2 as v6;
            v6.pvalue := v2.pvalue - 4;
            commit v6;
        }
        renew v3 as v7;
        v7.uvalue := v3.uvalue - 1;
        commit v7;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.OF := unknown;
}

pattern {
    asm repe_cmpsq;
} code {
    renew $cpu.rsi as v1;
    v1.type := $type.ptr($type.x64);
    commit v1;
    renew $cpu.rdi as v2;
    v2.type := $type.ptr($type.x64);
    commit v2;
    renew $cpu.rcx as v3;
    commit v3;
    for (;;) {
        join v8 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v6 to v1;
        join v7 to v2;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 64;
        commit v4;
        new v5;
        v5.addr := v2.pvalue;
        v5.bits := 64;
        commit v5;
        $flags.SF := v4.svalue < v5.svalue;
        $flags.CF := v4.uvalue < v5.uvalue;
        $flags.ZF := v4.value == v5.value;
        if ($flags.ZF == 0) {
            break;
        }
        if ($flags.DF == 0) {
            renew v2 as v6;
            v6.pvalue := v2.pvalue + 4;
            commit v6;
        } else {
            renew v2 as v6;
            v6.pvalue := v2.pvalue - 4;
            commit v6;
        }
        renew v3 as v7;
        v7.uvalue := v3.uvalue - 1;
        commit v7;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.OF := unknown;
}

alias asm repz_cmpsb := asm repe_cmpsb;
alias asm repz_cmpsw := asm repe_cmpsw;
alias asm repz_cmpsd := asm repe_cmpsd;
alias asm repz_cmpsq := asm repe_cmpsq;

pattern {
    asm repne_cmpsb;
} code {
    renew $cpu.rsi as v1;
    v1.type := $type.ptr($type.x8);
    commit v1;
    renew $cpu.rdi as v2;
    v2.type := $type.ptr($type.x8);
    commit v2;
    renew $cpu.rcx as v3;
    commit v3;
    for (;;) {
        join v8 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v6 to v1;
        join v7 to v2;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 8;
        commit v4;
        new v5;
        v5.addr := v2.pvalue;
        v5.bits := 8;
        commit v5;
        $flags.SF := v4.svalue < v5.svalue;
        $flags.CF := v4.uvalue < v5.uvalue;
        $flags.ZF := v4.value == v5.value;
        if ($flags.ZF == 1) {
            break;
        }
        if ($flags.DF == 0) {
            renew v2 as v6;
            v6.pvalue := v2.pvalue + 1;
            commit v6;
        } else {
            renew v2 as v6;
            v6.pvalue := v2.pvalue - 1;
            commit v6;
        }
        renew v3 as v7;
        v7.uvalue := v3.uvalue - 1;
        commit v7;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.OF := unknown;
}

pattern {
    asm repne_cmpsw;
} code {
    renew $cpu.rsi as v1;
    v1.type := $type.ptr($type.x16);
    commit v1;
    renew $cpu.rdi as v2;
    v2.type := $type.ptr($type.x16);
    commit v2;
    renew $cpu.rcx as v3;
    commit v3;
    for (;;) {
        join v8 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v6 to v1;
        join v7 to v2;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 16;
        commit v4;
        new v5;
        v5.addr := v2.pvalue;
        v5.bits := 16;
        commit v5;
        $flags.SF := v4.svalue < v5.svalue;
        $flags.CF := v4.uvalue < v5.uvalue;
        $flags.ZF := v4.value == v5.value;
        if ($flags.ZF == 1) {
            break;
        }
        if ($flags.DF == 0) {
            renew v2 as v6;
            v6.pvalue := v2.pvalue + 2;
            commit v6;
        } else {
            renew v2 as v6;
            v6.pvalue := v2.pvalue - 2;
            commit v6;
        }
        renew v3 as v7;
        v7.uvalue := v3.uvalue - 1;
        commit v7;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.OF := unknown;
}

pattern {
    asm repne_cmpsd;
} code {
    renew $cpu.rsi as v1;
    v1.type := $type.ptr($type.x32);
    commit v1;
    renew $cpu.rdi as v2;
    v2.type := $type.ptr($type.x32);
    commit v2;
    renew $cpu.rcx as v3;
    commit v3;
    for (;;) {
        join v8 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v6 to v1;
        join v7 to v2;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 32;
        commit v4;
        new v5;
        v5.addr := v2.pvalue;
        v5.bits := 32;
        commit v5;
        $flags.SF := v4.svalue < v5.svalue;
        $flags.CF := v4.uvalue < v5.uvalue;
        $flags.ZF := v4.value == v5.value;
        if ($flags.ZF == 1) {
            break;
        }
        if ($flags.DF == 0) {
            renew v2 as v6;
            v6.pvalue := v2.pvalue + 4;
            commit v6;
        } else {
            renew v2 as v6;
            v6.pvalue := v2.pvalue - 4;
            commit v6;
        }
        renew v3 as v7;
        v7.uvalue := v3.uvalue - 1;
        commit v7;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.OF := unknown;
}

pattern {
    asm repne_cmpsq;
} code {
    renew $cpu.rsi as v1;
    v1.type := $type.ptr($type.x64);
    commit v1;
    renew $cpu.rdi as v2;
    v2.type := $type.ptr($type.x64);
    commit v2;
    renew $cpu.rcx as v3;
    commit v3;
    for (;;) {
        join v8 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v6 to v1;
        join v7 to v2;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 64;
        commit v4;
        new v5;
        v5.addr := v2.pvalue;
        v5.bits := 64;
        commit v5;
        $flags.SF := v4.svalue < v5.svalue;
        $flags.CF := v4.uvalue < v5.uvalue;
        $flags.ZF := v4.value == v5.value;
        if ($flags.ZF == 1) {
            break;
        }
        if ($flags.DF == 0) {
            renew v2 as v6;
            v6.pvalue := v2.pvalue + 8;
            commit v6;
        } else {
            renew v2 as v6;
            v6.pvalue := v2.pvalue - 8;
            commit v6;
        }
        renew v3 as v7;
        v7.uvalue := v3.uvalue - 1;
        commit v7;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.OF := unknown;
}

alias asm repnz_cmpsb := asm repne_cmpsb;
alias asm repnz_cmpsw := asm repne_cmpsw;
alias asm repnz_cmpsd := asm repne_cmpsd;
alias asm repnz_cmpsq := asm repne_cmpsq;

pattern {
    asm cmpxchg $0, $1;
} code {
    static if ($0.bits == 64) {
        renew $cpu.rax as v1;
        commit v1;
        renew $0 as v2;
        commit v2;
        $flags.SF := v1.svalue < v2.svalue;
        $flags.CF := v1.uvalue < v2.uvalue;
        $flags.PF := unknown;
        $flags.AF := unknown;
        if (v1.value == v2.value) {
            renew $1 as v3;
            commit v3;
            renew $0 as v4;
            v4.value := v3.value;
            commit v4;
            $flags.ZF := 1;
        } else {
            renew $0 as v5;
            commit v5;
            renew v1 as v6;
            v6.value := v5.value;
            commit v6;
            $flags.ZF := 0;
        }
    } else static if ($0.bits == 32) {
        renew $cpu.eax as v7;
        commit v7;
        renew $0 as v8;
        commit v8;
        $flags.SF := v7.svalue < v8.svalue;
        $flags.CF := v7.uvalue < v8.uvalue;
        $flags.PF := unknown;
        $flags.AF := unknown;
        if (v7.value == v8.value) {
            renew $1 as v9;
            commit v9;
            renew $0 as v10;
            v10.value := v9.value;
            commit v10;
            $flags.ZF := 1;
        } else {
            renew $0 as v11;
            commit v11;
            renew v7 as v12;
            v12.value := v11.value;
            commit v12;
            $flags.ZF := 0;
        }
    } else static if ($0.bits == 16) {
        renew $cpu.ax as v13;
        commit v13;
        renew $0 as v14;
        commit v14;
        $flags.SF := v13.svalue < v14.svalue;
        $flags.CF := v13.uvalue < v14.uvalue;
        $flags.PF := unknown;
        $flags.AF := unknown;
        if (v13.value == v14.value) {
            renew $1 as v15;
            commit v15;
            renew $0 as v16;
            v16.value := v15.value;
            commit v16;
            $flags.ZF := 1;
        } else {
            renew $0 as v17;
            commit v17;
            renew v13 as v18;
            v18.value := v17.value;
            commit v18;
            $flags.ZF := 0;
        }
    } else static if ($0.bits == 8) {
        renew $cpu.al as v19;
        commit v19;
        renew $0 as v20;
        commit v20;
        $flags.SF := v19.svalue < v20.svalue;
        $flags.CF := v19.uvalue < v20.uvalue;
        $flags.PF := unknown;
        $flags.AF := unknown;
        if (v19.value == v20.value) {
            renew $1 as v21;
            commit v21;
            renew $0 as v22;
            v22.value := v21.value;
            commit v22;
            $flags.ZF := 1;
        } else {
            renew $0 as v23;
            commit v23;
            renew v19 as v24;
            v24.value := v23.value;
            commit v24;
            $flags.ZF := 0;
        }
    } else {
        assert(0);
    }
}

// cmpxchg8b(void *$m64);
// cmpxchg16b(void *$m128);
// cpuid();
// crc32($dest, $src);

pattern {
    asm cwd;
} code {
    renew $cpu.ax as v1;
    commit v1;
    renew $cpu.dx_ax as v2;
    v2.svalue := v1.svalue;
    commit v2;
}

pattern {
    asm cdq;
} code {
    renew $cpu.eax as v1;
    commit v1;
    renew $cpu.edx_eax as v2;
    v2.svalue := v1.svalue;
    commit v2;
}

pattern {
    asm cqo;
} code {
    renew $cpu.rax as v1;
    commit v1;
    renew $cpu.rdx_rax as v2;
    v2.svalue := v1.svalue;
    commit v2;
}

pattern {
    asm dec $0;
} code {
    renew $0 as v1;
    commit v1;
    renew v1 as v2;
    v2.value := v1.value - 1;
    commit v2;
    $flags.SF := v2.svalue < 0;
    $flags.ZF := v2.value == 0;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

pattern {
    asm div $0;
} code {
    renew $0 as v1;
    commit v1;
    static if ($0.bits == 64) {
        renew $cpu.rdx_rax as v2;
        commit v2;
        renew $cpu.rdx as v3;
        v3.uvalue := v2.uvalue % v1.uvalue;
        commit v3;
        renew $cpu.rax as v4;
        v4.uvalue := v2.uvalue / v1.uvalue;
        commit v4;
        update $cpu.rdx, $cpu.rax;
    } else static if ($0.bits == 32) {
        renew $cpu.edx_eax as v5;
        commit v5;
        renew $cpu.edx as v6;
        v6.uvalue := v5.uvalue % v1.uvalue;
        commit v6;
        renew $cpu.eax as v7;
        v7.uvalue := v5.uvalue / v1.uvalue;
        commit v7;
        update $cpu.edx, $cpu.eax;
    } else static if ($0.bits == 16) {
        renew $cpu.dx_ax as v8;
        commit v8;
        renew $cpu.dx as v9;
        v9.uvalue := v8.uvalue % v1.uvalue;
        commit v9;
        renew $cpu.ax as v10;
        v10.uvalue := v8.uvalue / v1.uvalue;
        commit v10;
        update $cpu.dx, $cpu.ax;
    } else static if ($0.bits == 8) {
        renew $cpu.ax as v11;
        commit v11;
        renew $cpu.ah as v12;
        v12.uvalue := v11.uvalue % v1.uvalue;
        commit v12;
        renew $cpu.al as v13;
        v13.uvalue := v11.uvalue / v1.uvalue;
        commit v13;
        update $cpu.al, $cpu.ah;
    } else {
        assert(0);
    }
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.SF := unknown;
    $flags.ZF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// asm enter $0, $1;

// asm hlt();

pattern {
    asm idiv $0;
} code {
    renew $0 as v1;
    commit v1;
    static if ($0.bits == 64) {
        renew $cpu.rdx_rax as v2;
        commit v2;
        renew $cpu.rdx as v3;
        v3.svalue := v2.svalue % v1.svalue;
        commit v3;
        renew $cpu.rax as v4;
        v4.svalue := v2.svalue / v1.svalue;
        commit v4;
        update $cpu.rdx, $cpu.rax;
    } else static if ($0.bits == 32) {
        renew $cpu.edx_eax as v5;
        commit v5;
        renew $cpu.edx as v6;
        v6.svalue := v5.svalue % v1.svalue;
        commit v6;
        renew $cpu.eax as v7;
        v7.svalue := v5.svalue / v1.svalue;
        commit v7;
        update $cpu.edx, $cpu.eax;
    } else static if ($0.bits == 16) {
        renew $cpu.dx_ax as v8;
        commit v8;
        renew $cpu.dx as v9;
        v9.svalue := v8.svalue % v1.svalue;
        commit v9;
        renew $cpu.ax as v10;
        v10.svalue := v8.svalue / v1.svalue;
        commit v10;
        update $cpu.dx, $cpu.ax;
    } else static if ($0.bits == 8) {
        renew $cpu.ax as v11;
        commit v11;
        renew $cpu.ah as v12;
        v12.svalue := v11.svalue % v1.svalue;
        commit v12;
        renew $cpu.al as v13;
        v13.svalue := v11.svalue / v1.svalue;
        commit v13;
        update $cpu.al, $cpu.ah;
    } else {
        assert(0);
    }
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.SF := unknown;
    $flags.ZF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

pattern {
    asm imul $0;
} code {
    renew $0 as v1;
    commit v1;
    static if ($0.bits == 64) {
        renew $cpu.rax as v2;
        commit v2;
        renew $cpu.rax_rax as v3;
        v3.svalue := v2.svalue * v1.svalue;
        commit v3;
    } else static if ($0.bits == 32) {
        renew $cpu.eax as v4;
        commit v4;
        renew $cpu.eax_eax as v5;
        v5.svalue := v4.svalue * v1.svalue;
        commit v5;
    } else static if ($0.bits == 16) {
        renew $cpu.ax as v6;
        commit v6;
        renew $cpu.ax_ax as v7;
        v7.svalue := v6.svalue * v1.svalue;
        commit v7;
    } else {
        assert(0);
    }
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.SF := unknown;
    $flags.ZF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

pattern {
    asm imul $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.svalue := v1.svalue * v2.svalue;
    commit v3;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.SF := unknown;
    $flags.ZF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

pattern {
    asm imul $0, $1, $2;
} code {
    renew $1 as v1;
    commit v1;
    renew $2 as v2;
    commit v2;
    renew $0 as v3;
    v3.svalue := v1.svalue * v2.svalue;
    commit v3;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.SF := unknown;
    $flags.ZF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// asm in $dest, $src;

pattern {
    asm inc $0;
} code {
    renew $0 as v1;
    commit v1;
    renew v1 as v2;
    v2.value := v1.value + 1;
    commit v2;
    $flags.SF := v2.svalue < 0;
    $flags.ZF := v2.value == 0;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// insb();
// insw();
// insd();
// int3();
// int($a);
// into();
// invd();
// invlpg($m);
// invpcid($dest, $src);
// iret();
// iretd();

pattern {
    asm ja $0;
} code {
    if ($flags.ZF == 1 && $flags.CF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jae $0;
} code {
    if ($flags.CF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jb $0;
} code {
    if ($flags.CF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jbe $0;
} code {
    if ($flags.ZF == 1 || $flags.CF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jc $0;
} code {
    if ($flags.CF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jcxz $0;
} code {
    if ($cpu.cx.value == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jecxz $0;
} code {
    if ($cpu.ecx.value == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jrcxz $0;
} code {
    if ($cpu.rcx.value == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm je $0;
} code {
    if ($flags.ZF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jg $0;
} code {
    if ($flags.ZF == 0 && $flags.SFeqOF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jge $0;
} code {
    if ($flags.SFeqOF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jl $0;
} code {
    if ($flags.SFeqOF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jle $0;
} code {
    if ($flags.ZF == 1 && $flags.SFeqOF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jmp $0;
} code {
    goto $0.avalue;
}

pattern {
    asm jna $0;
} code {
    if ($flags.ZF == 1 || $flags.CF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jnae $0;
} code {
    if ($flags.CF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jnb $0;
} code {
    if ($flags.CF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jnb $0;
} code {
    if ($flags.ZF == 0 && $flags.CF == 0 == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jnc $0;
} code {
    if ($flags.CF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jne $0;
} code {
    if ($flags.ZF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jng $0;
} code {
    if ($flags.ZF == 1 || $flags.SFeqOF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jnge $0;
} code {
    if ($flags.SFeqOF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jnl $0;
} code {
    if ($flags.SFeqOF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jnle $0;
} code {
    if ($flags.ZF == 0 && $flags.SFeqOF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jno $0;
} code {
    if ($flags.OF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jnp $0;
} code {
    if ($flags.PF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jns $0;
} code {
    if ($flags.SF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jnz $0;
} code {
    if ($flags.ZF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm jo $0;
} code {
    if ($flags.OF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jp $0;
} code {
    if ($flags.PF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jpe $0;
} code {
    if ($flags.PF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jpo $0;
} code {
    if ($flags.PF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm js $0;
} code {
    if ($flags.SF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm jz $0;
} code {
    if ($flags.ZF == 1) {
        goto $0.avalue;
    }
}

// lahf();
// lar($dest, $src);
// lds(void *$dest, void *$src);
// les(void *$dest, void *$src);
// lfs(void *$dest, void *$src);
// lgs(void *$dest, void *$src);

pattern {
    asm lea $0, $1;
} code {
    renew $0 as v1;
    v1.value := $1.addr;
    commit v1;
}

// lfence();
// lgdt($m1632);
// lidt($m1632);
// lldt($src);
// lmsw($src);
// lock();

pattern {
    asm lodsb;
} code {
    renew $cpu.rsi as v1;
    v1.type := $type.ptr($type.x8);
    commit v1;
    renew $cpu.al as v2;
    v2.value := *v1.pvalue;
    commit v2;
    if ($flags.DF == 0) {
        renew v1 as v3;
        v3.pvalue := v1.pvalue + 1;
        commit v3;
    } else {
        renew v1 as v3;
        v3.pvalue := v1.pvalue - 1;
        commit v3;
    }
    update $cpu.al;
    update $cpu.rsi;
}

pattern {
    asm lodsw;
} code {
    renew $cpu.rsi as v1;
    v1.type := $type.ptr($type.x16);
    commit v1;
    renew $cpu.ax as v2;
    v2.value := *v1.pvalue;
    commit v2;
    if ($flags.DF == 0) {
        renew v1 as v3;
        v3.pvalue := v1.pvalue + 2;
        commit v3;
    } else {
        renew v1 as v3;
        v3.pvalue := v1.pvalue - 2;
        commit v3;
    }
    update $cpu.ax;
    update $cpu.rsi;
}

pattern {
    asm lodsd;
} code {
    renew $cpu.rsi as v1;
    v1.type := $type.ptr($type.x32);
    commit v1;
    renew $cpu.eax as v2;
    v2.value := *v1.pvalue;
    commit v2;
    if ($flags.DF == 0) {
        renew v1 as v3;
        v3.pvalue := v1.pvalue + 4;
        commit v3;
    } else {
        renew v1 as v3;
        v3.pvalue := v1.pvalue - 4;
        commit v3;
    }
    update $cpu.ax;
    update $cpu.rsi;
}

pattern {
    asm lodsq;
} code {
    renew $cpu.rsi as v1;
    v1.type := $type.ptr($type.x64);
    commit v1;
    renew $cpu.rax as v2;
    v2.value := *v1.pvalue;
    commit v2;
    if ($flags.DF == 0) {
        renew v1 as v3;
        v3.pvalue := v1.pvalue + 8;
        commit v3;
    } else {
        renew v1 as v3;
        v3.pvalue := v1.pvalue - 8;
        commit v3;
    }
    update $cpu.rax;
    update $cpu.rsi;
}

pattern {
    asm rep_lodsb;
} code {
    renew $cpu.rsi as v1;
    v1.type := $type.ptr($type.x8);
    commit v1;
    renew $cpu.rcx as v2;
    commit v2;
    for (;;) {
        join v5 to v2;
        if (v2.uvalue == 0) {
            break;
        }
        renew $cpu.al as v3;
        v3.value := *v1.pvalue;
        commit v3;
        join v4 to v1;
        if ($flags.DF == 0) {
            renew v1 as v4;
            v4.pvalue := v4.pvalue + 1;
            commit v4;
        } else {
            renew v1 as v4;
            v4.pvalue := v4.pvalue - 1;
            commit v4;
        }
        renew v2 as v5;
        v5.uvalue := v2.uvalue - 1;
        commit v5;
    }
    update $cpu.al;
    update $cpu.rsi;
    renew v2 as v6;
    v6.value := 0;
    commit v6;
}

pattern {
    asm rep_lodsw;
} code {
    renew $cpu.rsi as v1;
    v1.type := $type.ptr($type.x16);
    commit v1;
    renew $cpu.rcx as v2;
    commit v2;
    for (;;) {
        join v5 to v2;
        if (v2.uvalue == 0) {
            break;
        }
        renew $cpu.ax as v3;
        v3.value := *v1.pvalue;
        commit v3;
        join v4 to v1;
        if ($flags.DF == 0) {
            renew v1 as v4;
            v4.pvalue := v4.pvalue + 2;
            commit v4;
        } else {
            renew v1 as v4;
            v4.pvalue := v4.pvalue - 2;
            commit v4;
        }
        renew v2 as v5;
        v5.uvalue := v2.uvalue - 1;
        commit v5;
    }
    update $cpu.ax;
    update $cpu.rsi;
    renew v2 as v6;
    v6.value := 0;
    commit v6;
}

pattern {
    asm rep_lodsd;
} code {
    renew $cpu.rsi as v1;
    v1.type := $type.ptr($type.x32);
    commit v1;
    renew $cpu.rcx as v2;
    commit v2;
    for (;;) {
        join v5 to v2;
        if (v2.uvalue == 0) {
            break;
        }
        renew $cpu.eax as v3;
        v3.value := *v1.pvalue;
        commit v3;
        join v4 to v1;
        if ($flags.DF == 0) {
            renew v1 as v4;
            v4.pvalue := v4.pvalue + 4;
            commit v4;
        } else {
            renew v1 as v4;
            v4.pvalue := v4.pvalue - 4;
            commit v4;
        }
        renew v2 as v5;
        v5.uvalue := v2.uvalue - 1;
        commit v5;
    }
    update $cpu.eax;
    update $cpu.rsi;
    renew v2 as v6;
    v6.value := 0;
    commit v6;
}

pattern {
    asm rep_lodsq;
} code {
    renew $cpu.rsi as v1;
    v1.type := $type.ptr($type.x64);
    commit v1;
    renew $cpu.rcx as v2;
    commit v2;
    for (;;) {
        join v5 to v2;
        if (v2.uvalue == 0) {
            break;
        }
        renew $cpu.rax as v3;
        v3.value := *v1.pvalue;
        commit v3;
        join v4 to v1;
        if ($flags.DF == 0) {
            renew v1 as v4;
            v4.pvalue := v4.pvalue + 8;
            commit v4;
        } else {
            renew v1 as v4;
            v4.pvalue := v4.pvalue - 8;
            commit v4;
        }
        renew v2 as v5;
        v5.uvalue := v2.uvalue - 1;
        commit v5;
    }
    update $cpu.rax;
    update $cpu.rsi;
    renew v2 as v6;
    v6.value := 0;
    commit v6;
}

pattern {
    asm loop $0;
} code {
    renew $cpu.rcx as v1;
    commit v1;
    if (v1.uvalue) {
        goto $0.avalue;
    }
    assert($cpu.cl.uvalue == 0);
    assert($cpu.ch.uvalue == 0);
    assert($cpu.cx.uvalue == 0);
    assert($cpu.ecx.uvalue == 0);
    assert($cpu.rcx.uvalue == 0);
}

pattern {
    asm loope $0;
} code {
    renew $cpu.rcx as v1;
    commit v1;
    if (v1.uvalue || $flags.ZF == 1) {
        goto $0.avalue;
    }
}

pattern {
    asm loopne $0;
} code {
    renew $cpu.rcx as v1;
    commit v1;
    if (v1.uvalue || $flags.ZF == 0) {
        goto $0.avalue;
    }
}

pattern {
    asm loopnz $0;
} code {
    renew $cpu.rcx as v1;
    commit v1;
    if (v1.uvalue || $flags.ZF == 0) {
        goto $0.avalue;
    }
}

pattern {
    loopz $0;
} code {
    renew $cpu.rcx as v1;
    commit v1;
    if (v1.uvalue || $flags.ZF == 1) {
        goto $0.avalue;
    }
}

// lsl($dest, $src);
// ltr($src);
// mfence();
// monitor();

pattern {
    mov $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    renew $0 as v2;
    v2.value := v1.value;
    commit v2;
    assert(v1.value == v2.value);
}

pattern {
    asm movbe $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    new b0;
    b0.bits := 8;
    b0.uvalue := (v1.uvalue & 0xFF);
    commit b0;
    new b1;
    b1.bits := 8;
    b1.uvalue := ((v1.uvalue >> 8) & 0xFF);
    commit b1;
    static if ($0.bits == 16) {
        renew $0 as v16;
        v16.uvalue := (b1.uvalue | (b0.uvalue << 8));
        commit v16;
    } else {
        new b2;
        b2.bits := 8;
        b2.uvalue := ((v1.uvalue >> 16) & 0xFF);
        commit b2;
        new b3;
        b3.bits := 8;
        b3.uvalue := ((v1.uvalue >> 24) & 0xFF);
        commit b3;
        new w0;
        w0.bits := 16;
        w0.uvalue := ((b0.uvalue << 8) | b1.uvalue)
        commit w0;
        new w1;
        w1.bits := 16;
        w1.uvalue := ((b2.uvalue << 8) | b3.uvalue)
        commit w1;
        static if ($0.bits == 32) {
            renew $0 as v32;
            v32.uvalue := ((w0.uvalue << 16) | w1.uvalue);
            commit v32;
        } else static if ($0.bits == 64) {
            new b4;
            b4.bits := 8;
            b4.uvalue := ((v1.uvalue >> 32) & 0xFF);
            commit b4;
            new b5;
            b5.bits := 8;
            b5.uvalue := ((v1.uvalue >> 40) & 0xFF);
            commit b5;
            new b6;
            b6.bits := 8;
            b6.uvalue := ((v1.uvalue >> 48) & 0xFF);
            commit b6;
            new b7;
            b7.bits := 8;
            b7.uvalue := ((v1.uvalue >> 56) & 0xFF);
            commit b7;
            new w2;
            w2.bits := 16;
            w2.uvalue := ((b4.uvalue << 8) | b5.uvalue)
            commit w2;
            new w3;
            w3.bits := 16;
            w3.uvalue := ((b6.uvalue << 8) | b7.uvalue)
            commit w3;
            new d0;
            d0.bits = 32;
            d0.uvalue := ((w0.uvalue << 16) | w1.uvalue);
            commit d0;
            new d1;
            d1.bits = 32;
            d1.uvalue := ((w2.uvalue << 16) | w3.uvalue);
            commit d1;
            renew $0 as v64;
            v64.uvalue := ((d0.uvalue << 32) | d1.uvalue);
            commit v64;
        } else {
            assert(0);
        }
    }
    update $0;
}

pattern {
    asm movbe $0, $1;
    assert($0.bits == 32);
} code {
    new v1;
    v1.addr := $1.addr;
    v1.bits := 32;
    commit v1;
    new v2;
    v2.bits := 8;
    v2.uvalue := (v1 & 0xFF);
    commit v2;
    new v3;
    v3.bits := 8;
    v3.uvalue := ((v1 >> 8) & 0xFF);
    commit v3;
    new v4;
    v4.bits := 8;
    v4.uvalue := ((v1 >> 16) & 0xFF);
    commit v4;
    new v5;
    v5.bits := 8;
    v5.uvalue := ((v1 >> 24) & 0xFF);
    commit v5;
    new v6;
    v6.bits := 16;
    v6.uvalue := ((v2.uvalue << 8) | v3.uvalue)
    commit v6;
    new v7;
    v7.bits := 16;
    v7.uvalue := ((v4.uvalue << 8) | v5.uvalue)
    commit v7;
    new v8;
    v8.addr := $0.addr;
    v8.bits := 32;
    v8.uvalue := ((v6.uvalue << 16) | v7.uvalue);
    update $0;
}

pattern {
    asm movbe $0, $1;
    assert($0.bits == 16);
} code {
    new v1;
    v1.addr := $1.addr;
    v1.bits := 16;
    commit v1;
    new v2;
    v2.bits := 8;
    v2.uvalue := (v1 & 0xFF);
    commit v2;
    new v3;
    v3.bits := 8;
    v3.uvalue := ((v1 >> 8) & 0xFF);
    commit v3;
    new v4;
    v4.addr := $0;
    v4.bits := 16;
    v4.uvalue := (v3.uvalue | (v2.uvalue << 8));
    commit v4;
}

pattern {
    asm movsb;
} code {
    renew $cpu.rsi as v1;
    v1.type := $type.ptr($type.x8);
    commit v1;
    renew $cpu.rdi as v2;
    v2.type := $type.ptr($type.x8);
    commit v2;
    new v3;
    v3.addr := v1.pvalue;
    v3.bits := 8;
    commit v3;
    new v4;
    v4.addr := v2.pvalue;
    v4.bits := 8;
    v4.value := v3.value;
    commit v4;
    if ($flags.DF == 0) {
        renew v1 as v5;
        v5.value := v1.value + 1;
        commit v5;
        renew v1 as v6;
        v6.value := v2.value + 1;
        commit v6;
    } else {
        renew v1 as v5;
        v5.value := v1.value - 1;
        commit v5;
        renew v1 as v6;
        v6.value := v2.value - 1;
        commit v6;
    }
}

pattern {
    asm movsw;
} code {
    renew $cpu.rsi as v1;
    v1.type := $type.ptr($type.x16);
    commit v1;
    renew $cpu.rdi as v2;
    v2.type := $type.ptr($type.x16);
    commit v2;
    new v3;
    v3.addr := v1.pvalue;
    v3.bits := 16;
    commit v3;
    new v4;
    v4.addr := v2.pvalue;
    v4.bits := 16;
    v4.value := v3.value;
    commit v4;
    if ($flags.DF == 0) {
        renew v1 as v5;
        v5.value := v1.value + 2;
        commit v5;
        renew v1 as v6;
        v6.value := v2.value + 2;
        commit v6;
    } else {
        renew v1 as v5;
        v5.value := v1.value - 2;
        commit v5;
        renew v1 as v6;
        v6.value := v2.value - 2;
        commit v6;
    }
}

pattern {
    asm movsd;
} code {
    renew $cpu.rsi as v1;
    v1.type := $type.ptr($type.x32);
    commit v1;
    renew $cpu.rdi as v2;
    v2.type := $type.ptr($type.x32);
    commit v2;
    new v3;
    v3.addr := v1.pvalue;
    v3.bits := 32;
    commit v3;
    new v4;
    v4.addr := v2.pvalue;
    v4.bits := 32;
    v4.value := v3.value;
    commit v4;
    if ($flags.DF == 0) {
        renew v1 as v5;
        v5.value := v1.value + 4;
        commit v5;
        renew v1 as v6;
        v6.value := v2.value + 4;
        commit v6;
    } else {
        renew v1 as v5;
        v5.value := v1.value - 4;
        commit v5;
        renew v1 as v6;
        v6.value := v2.value - 4;
        commit v6;
    }
}

pattern {
    asm movsd;
} code {
    renew $cpu.rsi as v1;
    v1.type := $type.ptr($type.x64);
    commit v1;
    renew $cpu.rdi as v2;
    v2.type := $type.ptr($type.x64);
    commit v2;
    new v3;
    v3.addr := v1.pvalue;
    v3.bits := 64;
    commit v3;
    new v4;
    v4.addr := v2.pvalue;
    v4.bits := 64;
    v4.value := v3.value;
    commit v4;
    if ($flags.DF == 0) {
        renew v1 as v5;
        v5.value := v1.value + 8;
        commit v5;
        renew v1 as v6;
        v6.value := v2.value + 8;
        commit v6;
    } else {
        renew v1 as v5;
        v5.value := v1.value - 8;
        commit v5;
        renew v1 as v6;
        v6.value := v2.value - 8;
        commit v6;
    }
}

pattern {
    asm rep_movsb;
} code {
    renew $cpu.rdi as v1;
    commit v1;
    renew $cpu.rdi as v2;
    commit v2;
    renew $cpu.rcx as v3;
    commit v3;
    static if ($flags.DF == 0) {
        $fn.memcpy(v2.pvalue, v1.pvalue, v3.uvalue);
        renew v1 as v4;
        v4.pvalue := v1.pvalue + v3.uvalue;
        commit v4;
        renew v2 as v5;
        v5.pvalue := v2.pvalue + v3.uvalue;
        commit v5;
        static if (v1.pvalue, v3.uvalue : constant) {
            continuous v1.pvalue, v1.pvalue + v3.uvalue;
        }
        static if (v2.pvalue, v3.uvalue : constant) {
            continuous v2.pvalue, v2.pvalue + v3.uvalue;
        }
    } else static if ($flags.DF == 1) {
        $fn.memcpy(v2.pvalue - v3.uvalue, v1.pvalue - v3.uvalue, v3.uvalue);
        renew v1 as v6;
        v6.pvalue := v1.pvalue - v3.uvalue;
        commit v6;
        renew v2 as v7;
        v7.pvalue := v2.pvalue - v3.uvalue;
        commit v7;
        static if (v1.pvalue, v3.uvalue : constant) {
            continuous v1.pvalue - v3.uvalue, v1.pvalue;
        }
        static if (v2.pvalue, v3.uvalue : constant) {
            continuous v2.pvalue - v3.uvalue, v2.pvalue;
        }
    } else {
        assert(0);
    }
    renew v3 as v8;
    v8.uvalue := 0;
    commit v8;
    update $cpu.rdi;
    update $cpu.rsi;
    update $cpu.rcx;
}

pattern {
    asm rep_movsw;
} code {
    renew $cpu.rdi as v1;
    commit v1;
    renew $cpu.rdi as v2;
    commit v2;
    renew $cpu.rcx as v3;
    commit v3;
    static if ($flags.DF == 0) {
        $fn.wmemcpy(v2.pvalue, v1.pvalue, v3.uvalue / 2);
        renew v1 as v4;
        v4.pvalue := v1.pvalue + v3.uvalue;
        commit v4;
        renew v2 as v5;
        v5.pvalue := v2.pvalue + v3.uvalue;
        commit v5;
        static if (v1.pvalue, v3.uvalue : constant) {
            continuous v1.pvalue, v1.pvalue + v3.uvalue;
        }
        static if (v2.pvalue, v3.uvalue : constant) {
            continuous v2.pvalue, v2.pvalue + v3.uvalue;
        }
    } else static if ($flags.DF == 1) {
        $fn.wmemcpy(v2.pvalue - v3.uvalue, v1.pvalue - v3.uvalue, v3.uvalue / 2);
        renew v1 as v6;
        v6.pvalue := v1.pvalue - v3.uvalue;
        commit v6;
        renew v2 as v7;
        v7.pvalue := v2.pvalue - v3.uvalue;
        commit v7;
        static if (v1.pvalue, v3.uvalue : constant) {
            continuous v1.pvalue - v3.uvalue, v1.pvalue;
        }
        static if (v2.pvalue, v3.uvalue : constant) {
            continuous v2.pvalue - v3.uvalue, v2.pvalue;
        }
    } else {
        assert(0);
    }
    renew v3 as v8;
    v8.uvalue := 0;
    commit v8;
    update $cpu.rdi;
    update $cpu.rsi;
    update $cpu.rcx;
}

pattern {
    asm rep_movsd;
} code {
    renew $cpu.rsi as v1;
    commit v1;
    renew $cpu.rdi as v2;
    commit v2;
    renew $cpu.rcx as v3;
    commit v3;
    for (;;) {
        join v6 to v3;
        if (!v3.value) {
            break;
        }
        new v4;
        v4.addr := v1.pvalue;
        commit v4;
        new v5;
        v5.addr := v2.pvalue;
        v5.value := v4.value;
        commit v5;
        join v6 to v1;
        join v7 to v2;
        if ($flags.DF == 0) {
            renew v1 as v6;
            v6.value := v1.value + 4;
            commit v6;
            renew v2 as v7;
            v7.value := v2.value + 4;
            commit v7;
        } else {
            renew v1 as v6;
            v6.value := v1.value - 4;
            commit v6;
            renew v2 as v7;
            v7.value := v2.value - 4;
            commit v7;
        }
        renew v3 as v8;
        v8.value := v3.value - 1;
        commit v8;
    }
    update $cpu.edi;
    update $cpu.esi;
    renew v3 as v9;
    v9.value := 0;
    commit v9;
    update $cpu.rcx;
}

pattern {
    movsx $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    renew $0 as v2;
    v2.svalue := v1.svalue;
    commit v2;
    assert(v1.svalue == v2.svalue);
}

pattern {
    asm movzx $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    renew $0 as v2;
    v2.uvalue := v1.uvalue;
    commit v2;
    assert(v1.uvalue == v2.uvalue);
}

pattern {
    asm mul $0;
} code {
    static if ($0.bits == 64) {
        renew $0 as v1;
        commit v1;
        renew $cpu.rax as v2;
        commit v2;
        renew $cpu.rdx_rax as v3;
        v3.uvalue := v1.uvalue * v2.uvalue;
        commit v3;
    } else static if ($0.bits == 32) {
        renew $0 as v4;
        commit v4;
        renew $cpu.eax as v5;
        commit v5;
        renew $cpu.edx_eax as v6;
        v6.uvalue := v4.uvalue * v5.uvalue;
        commit v6;
    } else static if ($0.bits == 16) {
        renew $0 as v7;
        commit v7;
        renew $cpu.ax as v8;
        commit v8;
        renew $cpu.dx_ax as v9;
        v9.uvalue := v7.uvalue * v8.uvalue;
        commit v9;
    } else static if ($0.bits == 8) {
        renew $0 as v10;
        commit v10;
        renew $cpu.al as v11;
        commit v11;
        renew $cpu.ax as v12;
        v12.uvalue := v10.uvalue * v11.uvalue;
        commit v12;
    } else {
        assert(0);
    }
    $flags.OF := unknown;
    $flags.CF := unknown;
    $flags.SF := unknown;
    $flags.ZF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

// mwait();

pattern {
    asm neg $0;
} code {
    renew $0 as v1;
    commit v1;
    renew v1 as v2;
    v2.svalue := -v1.svalue;
    commit v2;
    $flags.CF := v1.uvalue != 0;
    $flags.OF := unknown;
    $flags.SF := unknown;
    $flags.ZF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

pattern {
    asm not $0;
} code {
    renew $0 as v1;
    commit v1;
    renew v1 as v2;
    v2.uvalue := ~v1.uvalue;
    commit v2;
}

pattern {
    asm or $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    renew $0 as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := (v1.uvalue | v2.uvalue);
    commit v3;
    $flags.SF := v3.svalue < 0;
    $flags.ZF := v3.value == 0;
    $flags.OF := 0;
    $flags.CF := 0;
    $flags.PF := unknown;
    $flags.AF := unknown;
}

// out($dest, $src);
// outsb();
// outsw();
// outsd();
// rep_outsb();
// rep_outsw();
// rep_outsd();
// pause();

pattern {
    pop $0;
} code {
    renew $cpu.rsp as v1;
    commit v1;
    new v2;
    v2.addr := v1.pvalue;
    v2.bits := 64;
    commit v2;
    renew $0 as v3;
    v3.value := v2.value;
    commit v3;
    renew v1 as v4;
    v4.pvalue := v1.pvalue + 8;
    commit v4;
}

pattern {
    asm pop $0;
} code {
    pop $0;
}

pattern {
    asm popad;
} code {
    pop $cpu.rdi;
    pop $cpu.rsi;
    pop $cpu.rbp;
    pop $cpu.rsp;
    pop $cpu.rbx;
    pop $cpu.rdx;
    pop $cpu.rcx;
    pop $cpu.rax;
}


pattern {
    popcnt $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    new i1;
    i1.uvalue := 0;
    commit i1;
    new cnt1;
    cnt1.uvalue := 0;
    commit cnt1;
    for (;;) {
        if (v1.uvalue & (1 << i1.uvalue)) {
            renew cnt1 as cnt2;
            cnt2.uvalue := cnt1.uvalue + 1;
            commit cnt2;
        }
        renew i1 as i2;
        i2.uvalue := i1.uvalue + 1;
        commit i2;
        if (i2.uvalue >= $0.bits) {
            break;
        }
    }
    renew $0 as v2;
    v2.uvalue := cnt1.uvalue;
    commit v2;
}

// popf();
// popfd();
// prefetch0($m8);
// prefetch1($m8);
// prefetch2($m8);
// prefetchnta($m8);

pattern {
    asm pushad;
} code {
    new v1;
    v1.value := $cpu.esp;
    commit v1;
    push $cpu.eax;
    push $cpu.ecx;
    push $cpu.edx;
    push $cpu.ebx;
    push v1;
    push $cpu.ebp;
    push $cpu.esi;
    push $cpu.edi;
}

pattern {
    push $0;
} code {
    renew $0 as v1;
    commit v1;
    renew $cpu.rsp as v2;
    commit v2;
    new v3;
    v3.addr := v2.pvalue;
    v3.bits := 64;
    v3.value := v1.value;
    commit v3;
    renew v2 as v4;
    v4.pvalue := v2.pvalue - 8;
    commit v4;
}

// pushf();
// pushfd();
// rcl(XSIGNED $dest, XSIGNED $src);
// rcr(XSIGNED $dest, XSIGNED $src);

pattern {
    asm rol $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    renew $0 as v2;
    commit v2;
    static if ($0.bits == 64) {
        renew v2 as v3;
        v3.uvalue := $fn._rotl64(v2.uvalue, v1.uvalue);
        commit v3;
    } else {
        renew v2 as v4;
        v4.uvalue := $fn._rotl(v2.uvalue, v1.uvalue);
        commit v4;
    }
}

pattern {
    asm ror $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    renew $0 as v2;
    commit v2;
    static if ($0.bits == 64) {
        renew v2 as v3;
        v3.uvalue := $fn._rotr64(v2.uvalue, v1.uvalue);
        commit v3;
    } else {
        renew v2 as v4;
        v4.uvalue := $fn._rotr(v2.uvalue, v1.uvalue);
        commit v4;
    }
}

// rdmsr();
// rdpmc();
// rdrand($dest);
// rdtsc();
// rdtscp();

// rsm();
// sahf();

pattern {
    asm sal $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    renew $0 as v2;
    commit v2;
    renew v2 as v3;
    v3.svalue := v2.svalue << v1.uvalue;
    commit v3;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.ZF := v3.svalue == 0;
    $flags.SF := v3.svalue < 0;
    $flags.PF := unknown;
    $flags.AF := unknown;
}

pattern {
    asm sar $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    renew $0 as v2;
    commit v2;
    renew v2 as v3;
    v3.svalue := v2.svalue >> v1.uvalue;
    commit v3;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.ZF := v3.svalue == 0;
    $flags.SF := v3.svalue < 0;
    $flags.PF := unknown;
    $flags.AF := unknown;
}

pattern {
    asm shl $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    renew $0 as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := v2.uvalue << v1.uvalue;
    commit v3;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.ZF := v3.uvalue == 0;
    $flags.SF := v3.svalue < 0;
    $flags.PF := unknown;
    $flags.AF := unknown;
}

pattern {
    asm shr $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    renew $0 as v2;
    commit v2;
    renew v2 as v3;
    v3.uvalue := v2.uvalue >> v1.uvalue;
    commit v3;
    $flags.CF := unknown;
    $flags.OF := unknown;
    $flags.ZF := v3.uvalue == 0;
    $flags.SF := v3.svalue < 0;
    $flags.PF := unknown;
    $flags.AF := unknown;
}

pattern {
    sbb $0, $1;
} code {
    renew $1 as v1;
    commit v1;
    renew $0 as v2;
    commit v2;
    renew v2 as v3;
    if ($flags.CF == 1) {
        v3.svalue := v2.svalue - v1.svalue - 1;
    } else {
        v3.svalue := v2.svalue - v1.svalue;
    }
    $flags.OF := v3.svalue > v1.svalue;
    $flags.ZF := v3.svalue == 0;
    $flags.SF := v3.svalue < 0;
    $flags.CF := v2.uvalue < v1.uvalue;
    $flags.AF := unknown;
    $flags.PF := unknown;
}

pattern {
    asm scasb;
} code {
    renew $cpu.rdi as v1;
    commit v1;
    renew $cpu.al as v2;
    commit v2;
    new v3;
    v3.addr := v1.pvalue;
    v3.bits := 8;
    commit v3;
    $flags.OF := v2.svalue < v3.svalue;
    $flags.ZF := v2.value == v3.value;
    $flags.SF := v2.svalue < v3.svalue;
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.CF := unknown;
    if ($flags.DF == 0) {
        renew v1 as v4;
        v4.pvalue := v1.pvalue + 1;
        commit v4;
    } else {
        renew v1 as v4;
        v4.pvalue := v1.pvalue - 1;
        commit v4;
    }
    update $cpu.rdi;
}

pattern {
    asm scasw;
} code {
    renew $cpu.rdi as v1;
    commit v1;
    renew $cpu.ax as v2;
    commit v2;
    new v3;
    v3.addr := v1.pvalue;
    v3.bits := 16;
    commit v3;
    $flags.OF := v2.svalue < v3.svalue;
    $flags.ZF := v2.value == v3.value;
    $flags.SF := v2.svalue < v3.svalue;
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.CF := unknown;
    if ($flags.DF == 0) {
        renew v1 as v4;
        v4.pvalue := v1.pvalue + 2;
        commit v4;
    } else {
        renew v1 as v4;
        v4.pvalue := v1.pvalue - 2;
        commit v4;
    }
    update $cpu.rdi;
}

pattern {
    asm scasd;
} code {
    renew $cpu.rdi as v1;
    commit v1;
    renew $cpu.eax as v2;
    commit v2;
    new v3;
    v3.addr := v1.pvalue;
    v3.bits := 32;
    commit v3;
    $flags.OF := v2.svalue < v3.svalue;
    $flags.ZF := v2.value == v3.value;
    $flags.SF := v2.svalue < v3.svalue;
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.CF := unknown;
    if ($flags.DF == 0) {
        renew v1 as v4;
        v4.pvalue := v1.pvalue + 4;
        commit v4;
    } else {
        renew v1 as v4;
        v4.pvalue := v1.pvalue - 4;
        commit v4;
    }
    update $cpu.rdi;
}

pattern {
    asm scasq;
} code {
    renew $cpu.rdi as v1;
    commit v1;
    renew $cpu.rax as v2;
    commit v2;
    new v3;
    v3.addr := v1.pvalue;
    v3.bits := 64;
    commit v3;
    $flags.OF := v2.svalue < v3.svalue;
    $flags.ZF := v2.value == v3.value;
    $flags.SF := v2.svalue < v3.svalue;
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.CF := unknown;
    if ($flags.DF == 0) {
        renew v1 as v4;
        v4.pvalue := v1.pvalue + 8;
        commit v4;
    } else {
        renew v1 as v4;
        v4.pvalue := v1.pvalue - 8;
        commit v4;
    }
    update $cpu.rdi;
}

pattern {
    asm repe_scasb;
} code {
    renew $cpu.rdi as v1;
    commit v1;
    renew $cpu.al as v2;
    commit v2;
    renew $cpu.rcx as v3;
    commit v3;
    for (;;) {
        join v6 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v5 to v1;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 8;
        commit v4;
        $flags.OF := v2.svalue < v3.svalue;
        $flags.ZF := v2.value == v3.value;
        $flags.SF := v2.svalue < v3.svalue;
        if ($flags.ZF == 0) {
            break;
        }
        if ($flags.DF == 0) {
            renew v1 as v5;
            v5.pvalue := v1.pvalue + 1;
            commit v5;
        } else {
            renew v1 as v5;
            v5.pvalue := v1.pvalue - 1;
            commit v5;
        }
        renew v3 as v6;
        v6.uvalue := v3.uvalue - 1;
        commit v6;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.CF := unknown;
    update $cpu.rdi;
    $cpu.rcx.value := unknown;
    update $cpu.rcx;
}

pattern {
    asm repe_scasw;
} code {
    renew $cpu.rdi as v1;
    commit v1;
    renew $cpu.ax as v2;
    commit v2;
    renew $cpu.rcx as v3;
    commit v3;
    for (;;) {
        join v6 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v5 to v1;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 16;
        commit v4;
        $flags.OF := v2.svalue < v3.svalue;
        $flags.ZF := v2.value == v3.value;
        $flags.SF := v2.svalue < v3.svalue;
        if ($flags.ZF == 0) {
            break;
        }
        if ($flags.DF == 0) {
            renew v1 as v5;
            v5.pvalue := v1.pvalue + 2;
            commit v5;
        } else {
            renew v1 as v5;
            v5.pvalue := v1.pvalue - 2;
            commit v5;
        }
        renew v3 as v6;
        v6.uvalue := v3.uvalue - 1;
        commit v6;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.CF := unknown;
    update $cpu.rdi;
    $cpu.rcx.value := unknown;
    update $cpu.rcx;
}

pattern {
    asm repe_scasd;
} code {
    renew $cpu.rdi as v1;
    commit v1;
    renew $cpu.eax as v2;
    commit v2;
    renew $cpu.rcx as v3;
    commit v3;
    for (;;) {
        join v6 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v5 to v1;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 32;
        commit v4;
        $flags.OF := v2.svalue < v3.svalue;
        $flags.ZF := v2.value == v3.value;
        $flags.SF := v2.svalue < v3.svalue;
        if ($flags.ZF == 0) {
            break;
        }
        if ($flags.DF == 0) {
            renew v1 as v5;
            v5.pvalue := v1.pvalue + 4;
            commit v5;
        } else {
            renew v1 as v5;
            v5.pvalue := v1.pvalue - 4;
            commit v5;
        }
        renew v3 as v6;
        v6.uvalue := v3.uvalue - 1;
        commit v6;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.CF := unknown;
    update $cpu.rdi;
    $cpu.rcx.value := unknown;
    update $cpu.rcx;
}

pattern {
    asm repe_scasq;
} code {
    renew $cpu.rdi as v1;
    commit v1;
    renew $cpu.rax as v2;
    commit v2;
    renew $cpu.rcx as v3;
    commit v3;
    for (;;) {
        join v6 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v5 to v1;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 64;
        commit v4;
        $flags.OF := v2.svalue < v3.svalue;
        $flags.ZF := v2.value == v3.value;
        $flags.SF := v2.svalue < v3.svalue;
        if ($flags.ZF == 0) {
            break;
        }
        if ($flags.DF == 0) {
            renew v1 as v5;
            v5.pvalue := v1.pvalue + 8;
            commit v5;
        } else {
            renew v1 as v5;
            v5.pvalue := v1.pvalue - 8;
            commit v5;
        }
        renew v3 as v6;
        v6.uvalue := v3.uvalue - 1;
        commit v6;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.CF := unknown;
    update $cpu.rdi;
    $cpu.rcx.value := unknown;
    update $cpu.rcx;
}

alias asm repz_scasb := asm repe_scasb;
alias asm repz_scasw := asm repe_scasw;
alias asm repz_scasd := asm repe_scasd;
alias asm repz_scasq := asm repe_scasq;

pattern {
    asm repne_scasb;
} code {
    renew $cpu.rdi as v1;
    commit v1;
    renew $cpu.al as v2;
    commit v2;
    renew $cpu.rcx as v3;
    commit v3;
    for (;;) {
        join v6 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v5 to v1;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 8;
        commit v4;
        $flags.OF := v2.svalue < v3.svalue;
        $flags.ZF := v2.value == v3.value;
        $flags.SF := v2.svalue < v3.svalue;
        if ($flags.ZF == 1) {
            break;
        }
        if ($flags.DF == 0) {
            renew v1 as v5;
            v5.pvalue := v1.pvalue + 1;
            commit v5;
        } else {
            renew v1 as v5;
            v5.pvalue := v1.pvalue - 1;
            commit v5;
        }
        renew v3 as v6;
        v6.uvalue := v3.uvalue - 1;
        commit v6;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.CF := unknown;
    update $cpu.rdi;
    $cpu.rcx.value := unknown;
    update $cpu.rcx;
}

pattern {
    asm repne_scasw;
} code {
    renew $cpu.rdi as v1;
    commit v1;
    renew $cpu.ax as v2;
    commit v2;
    renew $cpu.rcx as v3;
    commit v3;
    for (;;) {
        join v6 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v5 to v1;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 16;
        commit v4;
        $flags.OF := v2.svalue < v3.svalue;
        $flags.ZF := v2.value == v3.value;
        $flags.SF := v2.svalue < v3.svalue;
        if ($flags.ZF == 1) {
            break;
        }
        if ($flags.DF == 0) {
            renew v1 as v5;
            v5.pvalue := v1.pvalue + 2;
            commit v5;
        } else {
            renew v1 as v5;
            v5.pvalue := v1.pvalue - 2;
            commit v5;
        }
        renew v3 as v6;
        v6.uvalue := v3.uvalue - 1;
        commit v6;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.CF := unknown;
    update $cpu.rdi;
    $cpu.rcx.value := unknown;
    update $cpu.rcx;
}

pattern {
    asm repne_scasd;
} code {
    renew $cpu.rdi as v1;
    commit v1;
    renew $cpu.eax as v2;
    commit v2;
    renew $cpu.rcx as v3;
    commit v3;
    for (;;) {
        join v6 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v5 to v1;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 32;
        commit v4;
        $flags.OF := v2.svalue < v3.svalue;
        $flags.ZF := v2.value == v3.value;
        $flags.SF := v2.svalue < v3.svalue;
        if ($flags.ZF == 1) {
            break;
        }
        if ($flags.DF == 0) {
            renew v1 as v5;
            v5.pvalue := v1.pvalue + 4;
            commit v5;
        } else {
            renew v1 as v5;
            v5.pvalue := v1.pvalue - 4;
            commit v5;
        }
        renew v3 as v6;
        v6.uvalue := v3.uvalue - 1;
        commit v6;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.CF := unknown;
    update $cpu.rdi;
    $cpu.rcx.value := unknown;
    update $cpu.rcx;
}

pattern {
    asm repne_scasq;
} code {
    renew $cpu.rdi as v1;
    commit v1;
    renew $cpu.rax as v2;
    commit v2;
    renew $cpu.rcx as v3;
    commit v3;
    for (;;) {
        join v6 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        join v5 to v1;
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 64;
        commit v4;
        $flags.OF := v2.svalue < v3.svalue;
        $flags.ZF := v2.value == v3.value;
        $flags.SF := v2.svalue < v3.svalue;
        if ($flags.ZF == 1) {
            break;
        }
        if ($flags.DF == 0) {
            renew v1 as v5;
            v5.pvalue := v1.pvalue + 8;
            commit v5;
        } else {
            renew v1 as v5;
            v5.pvalue := v1.pvalue - 8;
            commit v5;
        }
        renew v3 as v6;
        v6.uvalue := v3.uvalue - 1;
        commit v6;
    }
    $flags.AF := unknown;
    $flags.PF := unknown;
    $flags.CF := unknown;
    update $cpu.rdi;
    $cpu.rcx.value := unknown;
    update $cpu.rcx;
}

alias asm repnz_scasb := asm repne_scasb;
alias asm repnz_scasw := asm repne_scasw;
alias asm repnz_scasd := asm repne_scasd;
alias asm repnz_scasq := asm repne_scasq;

pattern {
    asm seta $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.ZF == 0 && $flags.CF == 0;
    commit v1;
}

pattern {
    asm setae $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.CF == 0;
    commit v1;
}

pattern {
    asm setb $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.CF;
    commit v1;
}

pattern {
    asm setbe $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.ZF == 1 || $flags.CF == 1;
    commit v1;
}

pattern {
    asm setc $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.CF;
    commit v1;
}

pattern {
    asm sete $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.ZF;
    commit v1;
}

pattern {
    asm setg $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.ZF == 0 && $flags.SFeqOF;
    commit v1;
}

pattern {
    asm setge $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.SFeqOF;
    commit v1;
}

pattern {
    asm setl $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.SFeqOF;
    commit v1;
}

pattern {
    asm setle $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.ZF && $flags.SFeqOF;
    commit v1;
}

pattern {
    asm setna $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.ZF && $flags.CF;
    commit v1;
}

pattern {
    asm setnae $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.CF;
    commit v1;
}

pattern {
    asm setnb $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.CF == 0;
    commit v1;
}

pattern {
    asm setnbe $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.ZF == 0 && $flags.CF == 0;
    commit v1;
}

pattern {
    asm setnc $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.CF == 0;
    commit v1;
}

pattern {
    asm setne $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.ZF == 0;
    commit v1;
}

pattern {
    asm setng $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.ZF || $flags.SFeqOF;
    commit v1;
}

pattern {
    asm setnge $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.SFeqOF;
    commit v1;
}

pattern {
    asm setnl $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.SFeqOF;
    commit v1;
}

pattern {
    asm setnle $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.ZF == 0 && $flags.SFeqOF;
    commit v1;
}

pattern {
    asm setno $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.OF == 0;
    commit v1;
}

pattern {
    asm setnp $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.PF == 0;
    commit v1;
}

pattern {
    asm setns $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.SF == 0;
    commit v1;
}

pattern {
    asm setnz $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.ZF == 0;
    commit v1;
}

pattern {
    asm seto $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.OF;
    commit v1;
}

pattern {
    asm setp $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.PF;
    commit v1;
}

pattern {
    asm setpe $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.PF;
    commit v1;
}

pattern {
    asm setpo $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.PF == 0;
    commit v1;
}

pattern {
    asm sets $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.SF;
    commit v1;
}

pattern {
    asm setz $0;
} code {
    new v1;
    v1.addr := $0.addr;
    v1.bits := 8;
    v1.value := $flags.ZF;
    commit v1;
}

// sfence();
// sgdt();
// shld($dest, $src, $count);   // TODO:
// shrd($dest, $src, $count);   // TODO:
// sidt($m);
// sldt($rm16);
// smsw($rm);

pattern {
    stc;
} code {
    $flags.CF := 1;
}

pattern {
    std;
} code {
    $flags.DF := 1;
}

pattern {
    sti;
} code {
    $flags.IF := 1;
}

pattern {
    asm stosb;
} code {
    renew $cpu.rdi as v1;
    commit v1;
    renew $cpu.al as v2;
    commit v2;
    new v3;
    v3.addr := v1.pvalue;
    v3.bits := 8;
    v3.value := v2.value;
    commit v3;
    if ($flags.DF == 0) {
        renew v1 as v4;
        v4.pvalue := v1.pvalue + 1;
        commit v4;
    } else {
        renew v1 as v4;
        v4.pvalue := v1.pvalue - 1;
        commit v4;
    }
    update $cpu.rdi;
}

pattern {
    asm stosw;
} code {
    renew $cpu.rdi as v1;
    commit v1;
    renew $cpu.ax as v2;
    commit v2;
    new v3;
    v3.addr := v1.pvalue;
    v3.bits := 16;
    v3.value := v2.value;
    commit v3;
    if ($flags.DF == 0) {
        renew v1 as v4;
        v4.pvalue := v1.pvalue + 2;
        commit v4;
    } else {
        renew v1 as v4;
        v4.pvalue := v1.pvalue - 2;
        commit v4;
    }
    update $cpu.rdi;
}

pattern {
    asm stosd;
} code {
    renew $cpu.rdi as v1;
    commit v1;
    renew $cpu.eax as v2;
    commit v2;
    new v3;
    v3.addr := v1.pvalue;
    v3.bits := 32;
    v3.value := v2.value;
    commit v3;
    if ($flags.DF == 0) {
        renew v1 as v4;
        v4.pvalue := v1.pvalue + 4;
        commit v4;
    } else {
        renew v1 as v4;
        v4.pvalue := v1.pvalue - 4;
        commit v4;
    }
    update $cpu.rdi;
}

pattern {
    asm stosq;
} code {
    renew $cpu.rdi as v1;
    commit v1;
    renew $cpu.rax as v2;
    commit v2;
    new v3;
    v3.addr := v1.pvalue;
    v3.bits := 64;
    v3.value := v2.value;
    commit v3;
    if ($flags.DF == 0) {
        renew v1 as v4;
        v4.pvalue := v1.pvalue + 8;
        commit v4;
    } else {
        renew v1 as v4;
        v4.pvalue := v1.pvalue - 8;
        commit v4;
    }
    update $cpu.rdi;
}

pattern {
    asm rep_stosb;
} code {
    renew $cpu.rdi as v1;
    commit v1;
    renew $cpu.al as v2;
    commit v2;
    renew $cpu.rcx as v3;
    commit v3;
    static if ($flags.DF == 0) {
        $fn.memset(v1.pvalue, v2.value, v3.uvalue);
        renew v1 as v4;
        v4.pvalue := v1.pvalue + v3.uvalue;
        commit v4;
        static if (v1.pvalue, v3.uvalue : constant) {
            continuous v1.pvalue, v1.pvalue + v3.uvalue;
        }
    } else {
        $fn.memset(v1.pvalue - v3.uvalue, v2.value, v3.uvalue);
        renew v1 as v5;
        v5.pvalue := v1.pvalue - v3.uvalue;
        commit v5;
        static if (v1.pvalue, v3.uvalue : constant) {
            continuous v1.pvalue - v3.uvalue, v1.pvalue;
        }
    }
    update $cpu.rdi;
    renew v3 as v6;
    v6.value := 0;
    commit v6;
    update $cpu.rcx;
}

pattern {
    asm rep_stosw;
} code {
    renew $cpu.rdi as v1;
    commit v1;
    renew $cpu.ax as v2;
    commit v2;
    renew $cpu.rcx as v3;
    commit v3;
    for (;;) {
        join v6 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 16;
        v4.value := v2.value;
        commit v4;
        join v5 to v1;
        if ($flags.DF == 0) {
            renew v1 as v5;
            v5.pvalue := v1.pvalue + 2;
            commit v5;
        } else {
            renew v1 as v5;
            v5.pvalue := v1.pvalue - 2;
            commit v5;
        }
        renew v3 as v6;
        v6.uvalue := v3.uvalue - 1;
        commit v6;
    }
    renew v3 as v7;
    v7.value := 0;
    commit v7;
    update $cpu.rcx;
}

pattern {
    asm rep_stosd;
} code {
    renew $cpu.rdi as v1;
    commit v1;
    renew $cpu.eax as v2;
    commit v2;
    renew $cpu.rcx as v3;
    commit v3;
    for (;;) {
        join v6 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 32;
        v4.value := v2.value;
        commit v4;
        join v5 to v1;
        if ($flags.DF == 0) {
            renew v1 as v5;
            v5.pvalue := v1.pvalue + 4;
            commit v5;
        } else {
            renew v1 as v5;
            v5.pvalue := v1.pvalue - 4;
            commit v5;
        }
        renew v3 as v6;
        v6.uvalue := v3.uvalue - 1;
        commit v6;
    }
    renew v3 as v7;
    v7.value := 0;
    commit v7;
    update $cpu.rcx;
}

pattern {
    asm rep_stosq;
} code {
    renew $cpu.rdi as v1;
    commit v1;
    renew $cpu.rax as v2;
    commit v2;
    renew $cpu.rcx as v3;
    commit v3;
    for (;;) {
        join v6 to v3;
        if (v3.uvalue == 0) {
            break;
        }
        new v4;
        v4.addr := v1.pvalue;
        v4.bits := 64;
        v4.value := v2.value;
        commit v4;
        join v5 to v1;
        if ($flags.DF == 0) {
            renew v1 as v5;
            v5.pvalue := v1.pvalue + 8;
            commit v5;
        } else {
            renew v1 as v5;
            v5.pvalue := v1.pvalue - 8;
            commit v5;
        }
        renew v3 as v6;
        v6.uvalue := v3.uvalue - 1;
        commit v6;
    }
    renew v3 as v7;
    v7.value := 0;
    commit v7;
    update $cpu.rcx;
}

// str($rm16);

pattern {
    sub $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.value := v1.value - v2.value;
    commit v3;
    $flags.SF := v1.svalue < v2.svalue;
    $flags.CF := v1.uvalue < v2.uvalue;
    $flags.ZF := v1.value == 0;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
}

pattern {
    subnf $0, $1;   // CodeReverse extension
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.value := v1.value - v2.value;
    commit v3;
    update $0;
}

// sysenter();
// sysexit();

pattern {
    test $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    new v1 as v3;
    v3.value := (v1.value & v2.value);
    commit v3;
    $flags.ZF := v3.value == 0;
    $flags.SF := v3.svalue < 0;
    $flags.CF := 0;
    $flags.OF := 0;
    $flags.PF := unknown;
    $flags.AF := unknown;
}

// ud2();
// verr($rm16);
// verw($rm16);
// wait();
// fwait();
// wbinvd();
// wrmsr();

pattern {
    xadd $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.value := v1.value + v2.value;
    commit v3;
    renew v2 as v4;
    v4.value := v1.value;
    commit v4;
    $flags.CF := v3.uvalue < v1.uvalue;
    $flags.SF := v4.svalue < 0;
    $flags.ZF := v4.value == 0;
    $flags.OF := unknown;
    $flags.AF := unknown;
    $flags.PF := unknown;
    update $0;
    update $1;
}

pattern {
    asm xchg $0, $1;
} code {
    swap $0, $1;
}

// xgetbv();

pattern {
    asm xlat $0;
} code {
    asm xlatb;
}

pattern {
    asm xlatb;
} code {
    renew $cpu.al as v1;
    commit v1;
    renew $cpu.rbx as v2;
    commit v2;
    new v3;
    v3.addr := v2.pvalue + v1.uvalue;
    v3.bits := 8;
    commit v3;
    renew v1 as v4;
    v4.value := v3.value;
    commit v4;
    update $cpu.al;
}

pattern {
    asm xor $0, $1;
} code {
    renew $0 as v1;
    commit v1;
    renew $1 as v2;
    commit v2;
    renew v1 as v3;
    v3.value := (v1.value ^ v2.value);
    $flags.SF := v3.svalue < 0;
    $flags.ZF := v3.value == 0;
    $flags.OF := 0;
    $flags.CF := 0;
    $flags.PF := unknown;
    $flags.AF := unknown;
    update $0;
}

// xrstor($mem);
// xsave($mem);
// xsaveopt($mem);
// xsetbv();
